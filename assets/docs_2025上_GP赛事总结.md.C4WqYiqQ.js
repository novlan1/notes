import{_ as o,c as i,o as c,ag as a}from"./chunks/framework.6d7lLjym.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2025上/GP赛事总结.md","filePath":"docs/2025上/GP赛事总结.md","lastUpdated":1744619817000}'),l={name:"docs/2025上/GP赛事总结.md"};function d(t,e,r,s,p,n){return c(),i("div",null,e[0]||(e[0]=[a('<h3 id="_1-介绍" tabindex="-1">1. 介绍 <a class="header-anchor" href="#_1-介绍" aria-label="Permalink to &quot;1. 介绍&quot;">​</a></h3><p>同步下和平赛场相关优化，包括工程、性能、用户体验等方面。业务价值包括：</p><ol><li>项目稳定，源源不断需求发布的情况下，现网bug数目由之前 &gt;=4 降到 &lt;= 1</li><li>性能提升，横版首屏由之前 3600ms+ 降到 2200ms</li><li>代码更健壮，代码规范问题 1000+ 降到 0</li><li>用户体验更流畅、顺滑</li></ol><h3 id="_2-工程" tabindex="-1">2. 工程 <a class="header-anchor" href="#_2-工程" aria-label="Permalink to &quot;2. 工程&quot;">​</a></h3><p>工程相关的包括提高代码质量、全量使用 <code>tailwindcss</code>、横版升级等。</p><p>这方面的业务价值就是提升了业务稳定性，相比之前，现网缺陷少了很多，代码质量上也有了提升。比起性能，工程上不好用数字表示，但个人感觉这个更重要，尤其是重构过大大小小的x山之后。</p><h4 id="_2-1-代码质量" tabindex="-1">2.1. 代码质量 <a class="header-anchor" href="#_2-1-代码质量" aria-label="Permalink to &quot;2.1. 代码质量&quot;">​</a></h4><p>和平赛场很大一部分前端工作都交给了外部开发者，如何保证他们的代码质量是关键。</p><p>目前采取了以下手段：</p><ol><li>任务分配上 <ul><li>分出去的都是相对简单的、非核心主流程的</li><li><strong>有明确的技术方案和实现路径</strong></li><li>尽量是业务中已有类似的代码，照猫画虎就能完成的</li></ul></li><li>加强代码审查 <ul><li>代码提测前CR一次，合主干前再CR一次，复杂点的需求两三天就要CR一次，再复杂的不会交出去</li><li>这里的CR节奏与其他项目并不完全一样，其他项目可能只CR到主干一次，很多问题发现不了。和平赛场这里还是继续坚持更频繁的CR</li><li>核心目的是<strong>尽早发现完题、尽早解决问题</strong></li></ul></li><li>充分利用工具 <ul><li>工具是最客观的、不知疲倦的、最高效的</li><li>支持保存文件自动格式化，新增代码提交前格式化检查</li><li>开发了 MR Lint 工具、定时全量 Lint 工具</li><li>引入了 <code>import/order</code>、<code>tailwindcss/classnames-order</code> 等更严格的规则</li><li><strong>工具 + 人治结合</strong>，保证代码质量、代码统一性</li></ul></li><li>核心代码物理隔离 <ul><li>历史规律看，只有物理隔离才能保证代码稳定可靠，否则他们<strong>一定会入侵他们可以接触到的代码（时间早晚问题）</strong>，分分钟给你搞乱，而涉及大量文件的CR你可能根本关注不到</li><li>和平赛场的核心逻辑、核心组件都沉淀到 <code>Press Next</code> 中，<code>Press Next</code> 比业务库代码要求更严格（如 TS 开启严格模式），且有单独的CR和发布管理</li></ul></li><li>提供常用组件、常用逻辑的使用方式指引</li><li>严格遵守流程 <ul><li>遵守开发、自测、测试、预发布、正式发布、现网验证等流程</li><li>现网发布必审批，组件库发布必审批</li></ul></li></ol><p>通过以上方法，尽量让代码可控，避免发现问题太晚。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_TYfWdx43eNXsw2Gj.png" width="500"><p></p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_n7Eiy2X4CX8AGYPY.png" width="500"><p>对代码规范的理解：</p><ol><li>自洽，自己配的规则自己要遵守，不要满屏飘红</li><li>统一，用一致的方式解决同一类问题，即便后面升级也方便脚本统一处理</li><li>安全，ESLint 中的一些规则可以提前发现问题，比如 <code>no-undef</code>、<code>no-dupe-class-members</code>、<code>vue/no-lone-template</code>，另一个方面，合并代码时冲突也大大减少</li><li>效率，利用好工具可以提升开发效率</li></ol><h4 id="_2-2-tailwindcss" tabindex="-1">2.2. tailwindcss <a class="header-anchor" href="#_2-2-tailwindcss" aria-label="Permalink to &quot;2.2. tailwindcss&quot;">​</a></h4><p><code>tailwindcss</code> 是CSS原子化的工具。</p><p>为什么用 <code>tailwindcss</code>？<a href="https://tailwindcss.com/docs/styling-with-utility-classes#overview" target="_blank" rel="noreferrer">官网</a>给了几个理由：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_FNTGH3wH3Z4bWns5.png" width="600"><p>对于我们项目而言，还有更深层次的原因：</p><ul><li>由于前端开发与UI开发分离，许多时候前端删掉了某些DOM结构，却不知道删掉对应的样式文件，造成性能问题</li><li>类名写的很乱，即便一个按钮也有无数种写法，难以维护。用 <code>tailwindcss</code> 之后，<strong>大部分情况下只有一个标准答案，会限制开发人员的“胡乱发挥”</strong></li><li>更重要的，更易沉淀，更易抽离，尤其是相对复杂的组件，也对应上面提到的核心代码隔离</li></ul><p>对于有些人认为的 <code>tailwindcss</code> 会让模板变成很长，造成难以维护。我是这样看待的：</p><ul><li>写的太少，不了解 <code>tailwindcss</code>，对于不熟的东西有天然的恐惧</li><li>没有规范，我这边的项目要求 <code>tailwindcss</code> 的类名一行一个，并增加 <code>ESLint</code> 的排序校验，保证所有人写出来的都一样</li><li>不懂数据驱动，如果发现完全一模一样的很长的类名，是不是忘记了 <code>v-for</code></li></ul><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_mWAxZ58BKndy5mD3.png" width="400"><p>个人对 <code>tailwindcss</code> 的理解：</p><ol><li>用工具帮开发者完成书写CSS，这个工具是无数测试用例、无数线上项目验证过的</li><li>简单、高效，<strong>让简单的事情回归简单</strong></li></ol><p>社区内使用 <code>tailwindcss</code> 或者其他原子化 CSS 的项目很多，比如 <code>github.com</code>、<code>x.com</code>，证明了它的成熟性。</p><p>为什么不用 <code>unocss</code>？主要是考虑是社区生态和活跃度，<code>tailwindcss</code> 生态链更成熟。<code>unocss</code> 那点编译速度的提升不足以弥补它在生态的不足、以及生产环境的不确定性。</p><h4 id="_2-3-横版项目-vue3-升级" tabindex="-1">2.3. 横版项目 Vue3 升级 <a class="header-anchor" href="#_2-3-横版项目-vue3-升级" aria-label="Permalink to &quot;2.3. 横版项目 Vue3 升级&quot;">​</a></h4><p>横版项目之前还是 Vue2，并且还有一些其他问题：</p><ul><li>大量冗余的CSS，性能差</li><li>大量全局样式，影响新增组件表现</li><li>大常量文件放到项目里，没有异步加载，性能差</li></ul><p>这里优化成了 Vue3 + Typescript，并解决了上面的问题。<code>Typescript</code> 带来的质量提升是巨大的，体会不到的人可能是一直使用了隐式 <code>any</code>。</p><h4 id="_2-4-其他" tabindex="-1">2.4. 其他 <a class="header-anchor" href="#_2-4-其他" aria-label="Permalink to &quot;2.4. 其他&quot;">​</a></h4><ol><li>将 <code>press-gp-dialog</code>、<code>press-toast</code> 等组件的 <code>dom</code> 内嵌在 <code>global-component</code> 中，这样每个页面只需要注入一个全局组件即可。同时，在 <code>main.ts</code> 中增加了这些组件调用时的默认 <code>selector</code>。好处是，降低开发成本，减少犯错。</li><li>开发了插件，检查循环依赖、子包引用主包等引用错误问题，避免潜在的错误</li></ol><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_cwwwkYFk6FiGNArY.png" width="500"><h3 id="_3-性能" tabindex="-1">3. 性能 <a class="header-anchor" href="#_3-性能" aria-label="Permalink to &quot;3. 性能&quot;">​</a></h3><p>横版由于升级了 Vue3，去掉了冗余样式，性能有比较大的提升，<strong>由 <code>3600ms+</code> 提升到了 <code>2200ms</code> 左右</strong>。</p><p>之前：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_FERcTby3TP525WWJ.png" width="500"><p>现在：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_Ynwr8EX2Q4YwRamE.png" width="500"><p>竖版性能部分其实做了很多工作，不过都被不停增长的需求、不同增加的代码体积抵消了，当前首屏时间约为 <code>2200ms</code> 左右，在赛事、商家同等量级、同等复杂度的业务中算是较好的。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_8xeSdcGKWcr6zian.png" width="500"><p>竖版性能相关优化具体介绍下。</p><h4 id="_3-1-tim-异步加载" tabindex="-1">3.1. tim 异步加载 <a class="header-anchor" href="#_3-1-tim-异步加载" aria-label="Permalink to &quot;3.1. tim 异步加载&quot;">​</a></h4><h5 id="_3-1-1-实现原理" tabindex="-1">3.1.1. 实现原理 <a class="header-anchor" href="#_3-1-1-实现原理" aria-label="Permalink to &quot;3.1.1. 实现原理&quot;">​</a></h5><p>IM 内部使用 <a href="https://www.npmjs.com/package/tim-js-sdk" target="_blank" rel="noreferrer">tim-js-sdk</a> 和 <a href="https://www.npmjs.com/package/tim-wx-sdk" target="_blank" rel="noreferrer">tim-wx-sdk</a>，分别用于 H5 和小程序。</p><p>H5 和 微信小程序均优化成了异步加载。</p><p>H5 的异步加载是用了 <code>little-loader</code>。</p><p>微信小程序的异步加载是用了 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/require.html" target="_blank" rel="noreferrer">require.async</a> 语法，并采用 <code>rollup-plugin-copy</code> 将 <code>node_modules</code> 下的 <code>tim-wx-sdk</code> 拷贝到 <code>views/tim-wx</code> 分包中。具体步骤：</p><ol><li>分包注册</li><li><code>require.async</code> 分包异步加载</li><li>复制三方库对应文件到分包目录</li></ol><h5 id="_3-1-2-效果" tabindex="-1">3.1.2. 效果 <a class="header-anchor" href="#_3-1-2-效果" aria-label="Permalink to &quot;3.1.2. 效果&quot;">​</a></h5><p>使用异步加载，微信小程序主包可以减小 <code>0.53M</code>。</p><p>之前：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_eeaf3c34a53915efc7.png" width="600"><p>异步加载之后：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_df60c9e4640c7a3e07.png" width="600"><p>使用异步加载，H5的体积可以减少 170 KB。</p><p>之前：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_e25ee9a8e6bd7ef716.png" width="600"><p>异步加载之后：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_030febad99995c54f0.png" width="600"><h4 id="_3-2-分享模板异步加载" tabindex="-1">3.2. 分享模板异步加载 <a class="header-anchor" href="#_3-2-分享模板异步加载" aria-label="Permalink to &quot;3.2. 分享模板异步加载&quot;">​</a></h4><h5 id="_3-2-1-当前痛点" tabindex="-1">3.2.1. 当前痛点 <a class="header-anchor" href="#_3-2-1-当前痛点" aria-label="Permalink to &quot;3.2.1. 当前痛点&quot;">​</a></h5><ol><li>引入了<code>jsapi</code>，体积太大，文件太多，可读性、可维护性太差。本来是非常简单的东西，加载<code>sdk</code>、调用全局变量即可，现在变得非常麻烦</li><li>类型缺失，使用、阅读、开发、调试困难 <ul><li>多个全局对象 <code>shareObject</code>、<code>shareUiObject</code> 没有类型</li><li>分享类别 <code>shareType</code> 没有类型，都是<code>1234</code>的魔法字符串</li><li>对外的API，比如 <code>initShare</code> 没有类型</li></ul></li><li>最关键的一点，分享根本不是首屏所需资源，不是必要路径，完全可以异步加载</li></ol><p>当前 <code>pmd</code> 体积:</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_1ee0e93a76cf00acf0.png" width="600"><p>把分享重定向到一个伪文件，即去掉分享后的 <code>pmd</code> 体积：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_43a0c42a4cb653343a.png" width="600"><p>可见分享模块的体积已经达到了 <code>97.49KB</code>，亟需优化。</p><p>光 <code>jsapi</code> 就有 <code>58.34KB</code>。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_d45c10acbf304f3975.png" width="600"><h5 id="_3-2-2-优化思路" tabindex="-1">3.2.2. 优化思路 <a class="header-anchor" href="#_3-2-2-优化思路" aria-label="Permalink to &quot;3.2.2. 优化思路&quot;">​</a></h5><ol><li>去掉 <code>jsapi</code></li><li>补充类型提示</li><li>封装异步加载逻辑，业务不关心</li></ol><p>其他：</p><ol><li><code>Toast</code>， <code>Dialog</code> 改为外部传入，方便切换组件库 <ul><li><code>Toast.show</code> =&gt; <code>showToast</code></li><li><code>Dialog.confirm</code> =&gt; <code>showConfirmDialog</code></li></ul></li><li><code>toast</code> 和 <code>dialog</code> 文案支持自定义</li><li><code>postGetMiniProgramOpenLink</code> 改为外部传入，可以充分自定义。传入的时候，就应该封装好参数，<code>share</code> 内部不关心。</li><li><code>configWx</code> 改为外部传入，适应任意业务</li><li>支持隐藏任意分享渠道，传入 <code>hideShareType</code> 参数即可，并把之前内部的账号判断移出 <code>share</code> 核心逻辑</li></ol><h5 id="_3-2-3-效果" tabindex="-1">3.2.3. 效果 <a class="header-anchor" href="#_3-2-3-效果" aria-label="Permalink to &quot;3.2.3. 效果&quot;">​</a></h5><p>减少 <code>85KB</code>。</p><p>之前：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_0ce48c3b497a47cc7b.png" width="600"><p>之后：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_8f266681fa965b8410.png" width="600"><h4 id="_3-3-其他" tabindex="-1">3.3. 其他 <a class="header-anchor" href="#_3-3-其他" aria-label="Permalink to &quot;3.3. 其他&quot;">​</a></h4><ol><li>开发了 <code>postcss</code> <a href="https://mobile.a.com/plugin-light/zh/postcss-plugin-remove-selector.html" target="_blank" rel="noreferrer">插件</a>，减少了 <code>press-icon-plus</code> 的样式体积 <code>15KB</code></li><li>将使用 <code>tim</code> 的页面都放到一个分包中</li></ol><h3 id="_4-用户体验" tabindex="-1">4. 用户体验 <a class="header-anchor" href="#_4-用户体验" aria-label="Permalink to &quot;4. 用户体验&quot;">​</a></h3><p>除了产品和其他人员提出的用户体验优化之外，前端主动优化了诸多用户体验部分。</p><h4 id="_4-1-登录优化" tabindex="-1">4.1. 登录优化 <a class="header-anchor" href="#_4-1-登录优化" aria-label="Permalink to &quot;4.1. 登录优化&quot;">​</a></h4><p>赛事即将开始时，平台会给参赛人员发携带比赛链接的短信。用户点击短信里的链接，会用浏览器打开。没有登录过或者登录失效时候，会展示登录框，点击其中的微信登录时，会弹一个二维码，用户需要截图并用微信扫码打开，步骤太多。</p><p>这里优化成了点击微信登录，就直接拉起小程序对应页面。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/2/own_mike_46a6960bf2b96d92d7.gif" width="300"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/2/own_mike_f6aec9336555447752.gif" width="300"><p>此外，之前是固定的 <code>scheme</code>，这里优化成弹出登录框时，<strong>判断当前 <code>url</code>，获取当前的页面、参数等信息，并动态拼接 <code>scheme</code>，注入到 <code>config</code> 中</strong>。让用户跳转到小程序后，打开的就是短信里的链接，无需再次点击。</p><p>下图是这一优化上线后，小程序的访问次数对比。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/3/own_mike_1a890f145f7c51545e.png" width="600"><h4 id="_4-2-页面切换增加切换效果" tabindex="-1">4.2. 页面切换增加切换效果 <a class="header-anchor" href="#_4-2-页面切换增加切换效果" aria-label="Permalink to &quot;4.2. 页面切换增加切换效果&quot;">​</a></h4><p>就是在页面切换时增加动画效果。左边是使用之前，右边是使用之后。使用后有切换动画，提升了流畅感。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/12/own_mike_2f9613b04c19a3c50f.gif" width="200"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/12/own_mike_1726c8e1bea10c9ff3.gif" width="200"><p>核心原理是借助了 <code>router</code> 的 <code>beforeEach</code> 和 <code>afterEach</code> 钩子，在路由跳转前后改变顶层类名，进而增加 <code>translateX</code> 相关动画。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/12/own_mike_d1e5f789f8ce463b57.png" width="300"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/12/own_mike_716cf8a6eab5168bb9.png" width="300"><h4 id="_4-3-pc-端展示优化" tabindex="-1">4.3. PC 端展示优化 <a class="header-anchor" href="#_4-3-pc-端展示优化" aria-label="Permalink to &quot;4.3. PC 端展示优化&quot;">​</a></h4><p>背景是 H5 用电脑浏览器打开时，会变形，宽高都会被拉长。现在优化成了在 PC 打开时，依然保持 H5 的样式。</p><p>效果对比如下，之前：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_phaTEJywawdnmr7F.png" width="500"><p>之后：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2025/5/own_mike_ZZCnPHkYPs2wxMW7.png" width="500"><p>原理为，在 PC 端打开一个 <code>iframe</code>，其宽高是手机的尺寸，其路径是想要打开的页面路径。</p><p>当发现是在PC打开，且不在白名单内时，就跳转到 <code>/web-container?path=xxx</code> 的路由，<code>xxx</code> 就是之前的 <code>window.location.href</code>。</p><p><code>web-container</code> 页面内是一个 <code>iframe</code>，会拿到页面的 <code>query.path</code>，将其作为 <code>iframe</code> 的 <code>src</code>。</p><p>当子应用页面跳转时，调用 <code>window.parent.history.replaceState</code>，更新 <code>query.path</code>，这样刷新页面，不会跳转到其他地方。</p><p>当发现是手机浏览器打开时，且当前是 <code>web-container</code> 模式，就 <code>router.replace</code> 到真正的页面，即去掉子应用。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/12/own_mike_6908e2b6ef5ea73567.png" width="500"><h4 id="_4-4-其他" tabindex="-1">4.4. 其他 <a class="header-anchor" href="#_4-4-其他" aria-label="Permalink to &quot;4.4. 其他&quot;">​</a></h4><ol><li>支持兜底路由（404页面重定向到首页）</li><li>跳转二级页面时，携带已有的信息并展示</li><li>核心页面增加骨架屏</li><li>通用 <a href="https://h5.igame.qq.com/pmd-mobile.pmd-h5.press-next.press-next/components/press/press-gp-popup-container.html" target="_blank" rel="noreferrer">popup-container</a> 关闭区域扩大</li><li>部分按钮、图标的 <code>active</code> 点击效果</li><li>赛事统计数字的 <a href="https://h5.igame.qq.com/pmd-mobile.support.press-ui.press-ui/components/press/press-rolling-text.html" target="_blank" rel="noreferrer">rollingText</a> 动效</li><li>切换 <code>tab</code> 后，更新 <code>query</code>，页面刷新后可以记录位置</li></ol><h3 id="_5-总结" tabindex="-1">5. 总结 <a class="header-anchor" href="#_5-总结" aria-label="Permalink to &quot;5. 总结&quot;">​</a></h3><p>和平赛场采取了一系列措施，保证代码质量，并优化了性能和用户体验，后面会继续加强、持续优化。</p><p>上面提到的很多点，影响方面并非只有一个，比如使用 <code>tailwindcss</code>，不止在工程上提升了效率，也防止了CSS的膨胀，提升了性能。</p><p>另外，上面的优化措施都有单独封装、沉淀，实际上已有不少其他项目已接入，欢迎有想法的找我交流。</p>',120)]))}const u=o(l,[["render",d]]);export{m as __pageData,u as default};
