import{_ as a,c as i,o as e,a2 as o}from"./chunks/framework.CriqKoQt.js";const s=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2022下/跨端工具链总结.md","filePath":"docs/2022下/跨端工具链总结.md","lastUpdated":1769413038000}'),t={name:"docs/2022下/跨端工具链总结.md"};function r(p,l,n,h,d,c){return e(),i("div",null,l[0]||(l[0]=[o('<h3 id="_1-背景" tabindex="-1">1. 背景 <a class="header-anchor" href="#_1-背景" aria-label="Permalink to &quot;1. 背景&quot;">​</a></h3><p>工具是生产力的基本，也是提升研发效能的关键。工具是一个个点，当把这些点封装好、关联好，串联起来，就构成了基础设施。团队需要持续不断的沉淀这些工具。</p><p>项目由web项目转为跨端项目过程中，积累了一系列工具，这里对一些核心工具进行下总结，主要包括原理、用法、效果等方面。</p><p>从宏观上说，这些工具解决的问题包括：</p><ol><li>瓶颈问题、卡脖子问题，不解决就无法继续进行，比如JS分发、组件分发，如果不解决，就无法满足小程序主包2M的限制，无法预览、上传、上线。</li><li>自动化相关，大幅减少工作量，以更优雅、更稳定的方式，替代手动改代码，提高效率</li></ol><p>从技术类别上，这些工具类型分为：</p><ol><li>Eslint插件</li><li>Webpack Loader</li><li>Webpack Plugin</li><li>脚手架工具，可视为node脚本的集合</li><li>CI相关</li></ol><h3 id="_2-工具" tabindex="-1">2. 工具 <a class="header-anchor" href="#_2-工具" aria-label="Permalink to &quot;2. 工具&quot;">​</a></h3><h4 id="_2-1-js分发" tabindex="-1">2.1. JS分发 <a class="header-anchor" href="#_2-1-js分发" aria-label="Permalink to &quot;2.1. JS分发&quot;">​</a></h4><p>JS分发和组件分发客观来说，是相对复杂的插件。</p><h5 id="_2-1-1-背景" tabindex="-1">2.1.1. 背景 <a class="header-anchor" href="#_2-1-1-背景" aria-label="Permalink to &quot;2.1.1. 背景&quot;">​</a></h5><p>由于uni-app对JS文件的打包策略并不完善，会将多个分包使用的JS都放到主包中，这会让主包变得特别大。因此需要将只有分包使用的JS文件转移到分包中。</p><h5 id="_2-1-2-原理" tabindex="-1">2.1.2. 原理 <a class="header-anchor" href="#_2-1-2-原理" aria-label="Permalink to &quot;2.1.2. 原理&quot;">​</a></h5><p>总体分为两步，第一步是先收集要移动的文件，第二步是真正移动。</p><p>收集过程是从 compilation.modules 过滤出vue文件，就是一个个module，然后获取这些 module 的 chunks，找到这些 chunks 对应的分包，如果有分包在使用，但是主包没在使用，就把它放入 moveFiles 中。</p><p>移动 module 过程如下。遍历 modules，如果某个 module 存在于 moveFiles 中，调用 module.getChunks 获取它的所有 chunks，如果只有 common/vendor 中包含这个 module，说明这个需要被放到分包中，并将 common/vendor 中的移除。</p><h5 id="_2-1-3-效果及扩展" tabindex="-1">2.1.3. 效果及扩展 <a class="header-anchor" href="#_2-1-3-效果及扩展" aria-label="Permalink to &quot;2.1.3. 效果及扩展&quot;">​</a></h5><p>JS分发插件使用后，主包大小减少了0.51M。</p><p>除了上面自动化的移动JS外，还实现了移动指定JS文件到指定分包的功能，扩展了插件的使用场景，可以让主包更小。</p><h4 id="_2-2-组件分发" tabindex="-1">2.2. 组件分发 <a class="header-anchor" href="#_2-2-组件分发" aria-label="Permalink to &quot;2.2. 组件分发&quot;">​</a></h4><h5 id="_2-2-1-背景" tabindex="-1">2.2.1. 背景 <a class="header-anchor" href="#_2-2-1-背景" aria-label="Permalink to &quot;2.2.1. 背景&quot;">​</a></h5><p>组件分发的灵感来自于uni-app源码中的提示，“将只有分包使用的组件移动到分包中”。</p><p>项目的一些公共组件，比如local-component、component中vue文件，会被打包到主包中，因此这里需要将只有分包使用的组件移动到分包中，但是如何在不改动项目架构的情况下实现这一功能呢？</p><h5 id="_2-2-2-原理" tabindex="-1">2.2.2. 原理 <a class="header-anchor" href="#_2-2-2-原理" aria-label="Permalink to &quot;2.2.2. 原理&quot;">​</a></h5><p>总体步骤如下：</p><ol><li>生成组件的基本相互引用关系</li><li>构建组件所有引用关系图</li><li>拉平上述组件关系</li><li>逆向获取使用一个组件的所有分包</li><li>根据组件使用的分包进行移动、删除主包内容等</li></ol><h5 id="_2-2-3-效果及扩展" tabindex="-1">2.2.3. 效果及扩展 <a class="header-anchor" href="#_2-2-3-效果及扩展" aria-label="Permalink to &quot;2.2.3. 效果及扩展&quot;">​</a></h5><p>使用组件分发插件后，主包大小减少了 2.17 M。</p><p>为了让插件更加灵活，可以适应不同项目，提供了几个配置选项：</p><ul><li>最大分包使用数目 maxUseTimes <ul><li>对一个组件，如果使用它的分包多于 maxUseTimes 时，就不再处理</li></ul></li><li>禁止移动的组件列表 disableList <ul><li>如果 disableList 中包含组件的路径和名称匹配到了，就不再处理</li></ul></li></ul><p>使用前：</p><img src="https://cdn.uwayfly.com/article/2022/8/uni-app-bundle-week-2.7.png" width="300"><p>使用后：</p><img src="https://cdn.uwayfly.com/article/2022/8/uni-app-bundle-week-2.6.png" width="300"><h4 id="_2-3-eslint插件" tabindex="-1">2.3. Eslint插件 <a class="header-anchor" href="#_2-3-eslint插件" aria-label="Permalink to &quot;2.3. Eslint插件&quot;">​</a></h4><p>开发了Eslint插件<code>eslint-plugin-pmd</code>，可以一键转化不符合跨端规范的代码，包括：</p><ol><li><p>禁止从js文件中加载Vue组件。 由于uni-app仅支持vue文件组件，并不能识别从js引入再导出的组件，所以这里需要自动转化。</p></li><li><p>禁止在vue的template中用+号转换字符串为数字 uni-app不允许<code>+str</code>语法，这里自动识别并自动转为<code>parseInt(str)</code></p></li><li><p>禁止在vue模板中使用复杂的key 对于字符串拼接<code>:key=&quot;</code>hold<code> + index&quot;</code>这种key会及时提示错误</p></li></ol><h4 id="_2-4-全局组件插入loader" tabindex="-1">2.4. 全局组件插入loader <a class="header-anchor" href="#_2-4-全局组件插入loader" aria-label="Permalink to &quot;2.4. 全局组件插入loader&quot;">​</a></h4><p>对于一些所有页面都在使用的组件，用loader的方式自动注入，提升了效率，也减少了出错的可能。</p><h4 id="_2-5-page-meta插入loader" tabindex="-1">2.5. page-meta插入loader <a class="header-anchor" href="#_2-5-page-meta插入loader" aria-label="Permalink to &quot;2.5. page-meta插入loader&quot;">​</a></h4><p>微信小程序原生支持rem，但是需要插件page-meta标签，这里也是用loader自动注入。</p><h4 id="_2-6-替换web端组件" tabindex="-1">2.6. 替换web端组件 <a class="header-anchor" href="#_2-6-替换web端组件" aria-label="Permalink to &quot;2.6. 替换web端组件&quot;">​</a></h4><p>一些web端的组件也会被打包进小程序的产物中，因为小程序模式下无法开启tree-shaking。因此这里需要用工具将一些没用的组件消除掉。</p><p>替换一个文件有两种方式：</p><ol><li>将引入文件的地址替换，比如import { Button } from &#39;vant&#39;，可以将vant转为一个另一个文件，import { Button } from &#39;fake-comp&#39;;</li><li>加载文件时，用新内容替换，对于上面的例子，就是加载vant时，直接替换掉。</li></ol><p>对于三方库，用的是第1种方式，对于本地文件，用的是第2种方式。</p><h4 id="_2-7-懒加载的兼容" tabindex="-1">2.7. 懒加载的兼容 <a class="header-anchor" href="#_2-7-懒加载的兼容" aria-label="Permalink to &quot;2.7. 懒加载的兼容&quot;">​</a></h4><p>web用的是lazyload这个三方库，而小程序自带lazyload属性，所以实现了一种根据编译环境，自动选择合适的懒加载方案的loader。</p><h4 id="_2-8-调试工具" tabindex="-1">2.8. 调试工具 <a class="header-anchor" href="#_2-8-调试工具" aria-label="Permalink to &quot;2.8. 调试工具&quot;">​</a></h4><p>实现了小程序打包产物中自动注入构建信息的工具，方便查看：</p><ul><li>最后一次commit信息</li><li>构建环境</li><li>版本是否被覆盖、是否是最新的</li><li>当前是测试环境还是线上环境</li></ul><img src="https://cdn.uwayfly.com/article/2022/11/mp-debug.pic.jpg" width="300"><h4 id="_2-9-基于摩斯密码的加密" tabindex="-1">2.9. 基于摩斯密码的加密 <a class="header-anchor" href="#_2-9-基于摩斯密码的加密" aria-label="Permalink to &quot;2.9. 基于摩斯密码的加密&quot;">​</a></h4><p>实现了基于摩斯密码的加密方案，可以在小程序中隐藏对应的h5路由信息，方便开发者调试定位问题。</p><img src="https://cdn.uwayfly.com/article/2022/10/morse-1664680424742.png" width="500"><h4 id="_2-10-路由hook" tabindex="-1">2.10. 路由hook <a class="header-anchor" href="#_2-10-路由hook" aria-label="Permalink to &quot;2.10. 路由hook&quot;">​</a></h4><p>用hook的方式扩展uni-simple-router的路由模式，可以做到不改代码，也可以保留h5的功能多样性。</p><h4 id="_2-11-ci相关" tabindex="-1">2.11. CI相关 <a class="header-anchor" href="#_2-11-ci相关" aria-label="Permalink to &quot;2.11. CI相关&quot;">​</a></h4><p>实现了微信小程序和qq小程序的自动构建、自动上传、自动预览的功能，主要解决了以下痛点：</p><ul><li><p>构建时间长，流程繁琐</p></li><li><p>外部开发人员无法预览</p></li></ul><p>本次CI功能点如下：</p><ul><li>自动进行uni-app打包，打包两份：test和release环境</li><li>将打包产物自动上传</li><li>自动预览、生成图片</li><li>将预览图片上传到腾讯云</li><li>发送构建通知、腾讯云图片地址到企业微信</li></ul><p>下面是一些相对于其他CI的优化点：</p><ul><li>多环境区分 <ul><li>对于开发版，同一个开发者只能保留一份，当我们既想看测试环境，又想看正式环境时就捉襟见肘了。</li><li>借助小程序ci，对多个环境用不同的机器人，这样就不会覆盖了。</li></ul></li><li>配置驱动 <ul><li>由于小程序ci机器人范围有限（1-30），所以只能手动维护，让其重复利用。</li><li>这里我让项目每个分支每个环境分别对应一个机器人，当一个分支废弃后，这个机器人就可以释放给其他分支使用。</li><li>同时其他配置项也可以统一保管起来，比如腾讯云密钥、小程序密钥等，方便维护</li></ul></li><li>自动重试 <ul><li>有时候上传或者预览会失败，可能是环境问题，也可能是多个流水线同时上传会冲突，因为需要增加自动重试功能。</li></ul></li><li>并行提速 <ul><li>上传和预览是可以同步进行的，这样可以节省一些构建时间。</li></ul></li><li>canvas绘图 <ul><li>小程序ci默认提供的图片只有二维码，笔者用canvas将一些构建信息和二维码绘制到一张新图上，方便定位和查看。</li><li>绘制的信息示例：</li><li>版本号：1.0.5</li><li>提交者：CI机器人5</li><li>环境：test</li><li>分支：release</li><li>构建时间：2022-10-19: 09:36:37</li><li>最后提交：lee - 修复page</li><li>二维码</li></ul></li></ul><p>目前，CI流水线日均构建30+次，每次构建时间6min左右，每日可节省工时180min+。</p><img src="https://cdn.uwayfly.com/article/2022/11/mp-robot.pic.jpg" width="600"><h3 id="_3-工程化" tabindex="-1">3. 工程化 <a class="header-anchor" href="#_3-工程化" aria-label="Permalink to &quot;3. 工程化&quot;">​</a></h3><p>由于loader的机制接近于黑盒子，为了保证工具的稳定性，需要用完善的测试用例覆盖，其他工具也是如此。</p><p>这里我将上述的loader、plugin抽离出来，并用ts+jest+rollup重构，单独发了npm包uni-plugin-light，好处是：</p><ul><li>方便其他项目接入</li><li>核心方法必须通过单元测试，提高了工具的可用性，减少了bug率</li><li>方便扩展</li></ul><img src="https://cdn.uwayfly.com/article/2022/11/uni-plugin-light-test.pic.jpg" width="500"><h3 id="_4-其他工具" tabindex="-1">4. 其他工具 <a class="header-anchor" href="#_4-其他工具" aria-label="Permalink to &quot;4. 其他工具&quot;">​</a></h3><p>除了上述跨端工具外，这里也简单介绍下一些其他实用工具：</p><ul><li>eslint-plugin-light，一行代码完成eslint配置</li><li>开源治理日报机器人，每日提醒代码规范、代码安全问题</li><li>TAM日报，每次发送项目PV、UV、错误率、性能数据，方便开发人员查看</li><li>公共库自动打Tag、自动升版本，并发送changelog到企业微信群中</li><li>七彩石配置自动同步COS，方便使用</li></ul><img src="https://cdn.uwayfly.com/article/2022/11/common-robot.pic.jpg" width="300"><img src="https://cdn.uwayfly.com/article/2022/11/open-source-report.pic.jpg" width="500"><h3 id="_5-总结及后续规划" tabindex="-1">5. 总结及后续规划 <a class="header-anchor" href="#_5-总结及后续规划" aria-label="Permalink to &quot;5. 总结及后续规划&quot;">​</a></h3><p>在日常开发中，开发了一系列工具，解决了一些针对性的问题，提升了效率。</p><p>除了工具链外，前端开发中另一个重要的部分是组件库，由于分工过细、赶需求等，规范的组件库一直没有沉淀下来，后面会加强此方面的建设，构建高可用、灵活的组件库。</p>',79)]))}const m=a(t,[["render",r]]);export{s as __pageData,m as default};
