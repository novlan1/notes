import{_ as s,c as a,o as e,a2 as n}from"./chunks/framework.CriqKoQt.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2022上/ReactFiber.md","filePath":"docs/2022上/ReactFiber.md","lastUpdated":1771599431000}'),l={name:"docs/2022上/ReactFiber.md"};function t(p,i,h,r,k,d){return e(),a("div",null,i[0]||(i[0]=[n(`<h2 id="一、react架构" tabindex="-1">一、React架构 <a class="header-anchor" href="#一、react架构" aria-label="Permalink to &quot;一、React架构&quot;">​</a></h2><p>React15架构可以分为两层：</p><ul><li>Reconciler（协调器），负责找出变化的组件</li><li>Renderer（渲染器），负责将变化的组件渲染到页面上</li></ul><p>在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等API触发更新。每当有更新发生时，Reconciler会做如下工作：</p><ol><li>调用函数组件或class组件的render方法，将返回的JSX转化为虚拟DOM</li><li>将虚拟DOM和上次更新时的虚拟DOM对比</li><li>通过对比找出本次更新中变化的虚拟DOM</li><li>通知Renderer将变化的虚拟DOM渲染到页面上</li></ol><p>由于React支持跨平台，所以不同平台有不同的Renderer。在浏览器环境渲染的Renderer是ReactDOM。除此之外，还有：</p><ul><li>ReactNative 渲染器，渲染App原生组件</li><li>ReactTest 渲染器，渲染出纯Js对象用于测试</li><li>ReactArt 渲染器，渲染到Canvas, SVG 或 VML (IE8)</li></ul><p>在每次更新发生时，Renderer接到Reconciler通知，将变化的组件渲染在当前宿主环境。</p><p>React15架构中，在Reconciler时，mount的组件会调用mountComponent，update的组件会调用updateComponent。这两个方法都会递归更新子组件。</p><p>递归更新的缺点是，一旦更新开始，中途就无法中断。JS引擎和页面渲染引擎是在同一个渲染线程之内，两者是互斥关系。如果在某个阶段执行任务特别长，时间已经明显超过了16ms，那么就会阻塞页面的渲染，从而出现卡顿现象。</p><p>React16之后将递归的无法中断的更新重构为异步的可中断更新。React16架构可以分为三层：</p><ul><li>Scheduler（调度器），调度任务的优先级，高优任务优先进入Reconciler</li><li>Reconciler（协调器），负责找出变化的组件</li><li>Renderer（渲染器），负责将变化的组件渲染到页面上</li></ul><p>为什么Vue不需要使用Fiber？</p><ul><li>Vue 是基于 template 和 watcher 的组件级更新，把每个更新任务分割得足够小，不需要使用到 Fiber 架构，将任务进行更细粒度的拆分。</li><li>React 是不管在哪里调用 setState，都是从根节点开始更新的，更新任务还是很大，需要使用到 Fiber 将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务。</li></ul><h2 id="二、fiber" tabindex="-1">二、Fiber <a class="header-anchor" href="#二、fiber" aria-label="Permalink to &quot;二、Fiber&quot;">​</a></h2><p>Fiber 可以理解为是一个执行单元，也可以理解为是一种数据结构。</p><p>Fiber 可以被理解为划分一个个更小的执行单元，它是把一个大任务拆分为了很多个小块任务，一个小块任务的执行必须是一次完成的，不能出现暂停，但是一个小块任务执行完后可以移交控制权给浏览器去响应用户。</p><p>React 向浏览器请求调度，浏览器在一帧中如果还有空闲时间，会去判断是否存在待执行任务，不存在就直接将控制权交给浏览器，如果存在就会执行对应的任务，执行完成后会判断是否还有时间，有时间且有待执行任务则会继续执行下一个任务，否则就会将控制权交给浏览器。</p><p>Fiber 还可以理解为是一种数据结构，React Fiber 就是采用链表实现的。每个 Virtual DOM 都可以表示为一个 fiber，每个节点都是一个 fiber。一个 fiber包括了 child（第一个子节点）、sibling（兄弟节点）、return（父节点）等属性</p><h2 id="三、requestidlecallback" tabindex="-1">三、requestIdleCallback <a class="header-anchor" href="#三、requestidlecallback" aria-label="Permalink to &quot;三、requestIdleCallback&quot;">​</a></h2><p>requestIdleCallback 是一个实验中的新API，这个API调用方式如下:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestIdleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback[, options])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cancelIdleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(handle)</span></span></code></pre></div><p>requestIdleCallback接收一个回调，这个回调会在浏览器空闲时调用，每次调用会传入一个IdleDeadline，可以拿到当前还空余多久，options可以传入参数最多等多久，等到了时间浏览器还不空就强制执行了。使用这个API可以解决任务调度的问题，让浏览器在空闲时才计算diff并渲染。</p><h2 id="四、fiber执行原理" tabindex="-1">四、Fiber执行原理 <a class="header-anchor" href="#四、fiber执行原理" aria-label="Permalink to &quot;四、Fiber执行原理&quot;">​</a></h2><p>从根节点开始渲染和调度的过程可以分为两个阶段：render 阶段、commit 阶段。</p><ul><li>render 阶段：这个阶段是可中断的，会找出所有节点的变更</li><li>commit 阶段：这个阶段是不可中断的，会执行所有的变更</li></ul><p>render阶段中，会将虚拟DOM树转化为Fiber tree，以虚拟dom节点为维度对任务进行拆分，即一个虚拟dom节点对应一个任务，最后产出的结果是effect list，从中可以知道哪些节点更新、哪些节点增加、哪些节点删除了。</p><p>遍历Fiber tree的时候从根节点出发，先找子元素，如果子元素存在，直接返回，如果没有子元素了就找兄弟元素，找完所有的兄弟元素后再返回父元素，然后再找这个父元素的兄弟元素。整个遍历过程其实是后序遍历。比如下图从div1开始遍历的话，遍历的顺序就应该是div1 -&gt; div2 -&gt; div3 -&gt; p2 -&gt; div2 -&gt; p1 -&gt; div1。</p><img src="http://doc.uwayfly.com/react-fiber.png" width="380"><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> performUnitOfWork</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Fiber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  beginWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Fiber)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Fiber.child) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fiber.child</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Fiber) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    completeUnitWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Fiber)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Fiber.sibling) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fiber.sibling</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Fiber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fiber.return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> workloop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nextUnitOfWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nextUnitOfWork) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nextUnitOfWork </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> performUnitOfWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextUnitOfWork)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nextUnitOfWork) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;reconciliation阶段结束&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">workloop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rootFiber)</span></span></code></pre></div><p>commit 阶段需要将上阶段计算出来的需要处理的副作用一次性执行，此阶段不能暂停，否则会出现UI更新不连续的现象。此阶段需要根据effect list，将所有更新都 commit 到DOM树上。</p><h2 id="五、相关资料" tabindex="-1">五、相关资料 <a class="header-anchor" href="#五、相关资料" aria-label="Permalink to &quot;五、相关资料&quot;">​</a></h2><ol><li><a href="https://juejin.cn/post/6898292945867571207" target="_blank" rel="noreferrer">手写React核心原理，再也不怕面试官问我react原理</a></li><li><a href="https://juejin.cn/post/6844904197008130062" target="_blank" rel="noreferrer">手写React的Fiber架构，深入理解其原理</a></li><li><a href="https://juejin.cn/post/6943896410987659277" target="_blank" rel="noreferrer">走进React Fiber的世界</a></li></ol>`,33)]))}const o=s(l,[["render",t]]);export{c as __pageData,o as default};
