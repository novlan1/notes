import{_ as a,c as e,o as r,ag as o}from"./chunks/framework.6d7lLjym.js";const l=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2024上/安全沙箱.md","filePath":"docs/2024上/安全沙箱.md","lastUpdated":1763569812000}'),s={name:"docs/2024上/安全沙箱.md"};function n(p,t,i,c,d,g){return r(),e("div",null,t[0]||(t[0]=[o('<p>下面我们重点从操作系统安全的视角来看看浏览器的多进程架构，如下图：</p><img src="https://static001.geekbang.org/resource/image/b8/b1/b83693a1ace43f43f9cab242982de6b1.png?wh=1142*1024" width="600"><p>观察上图，我们知道浏览器被划分为浏览器内核和渲染内核两个核心模块，其中<strong>浏览器内核是由网络进程、浏览器主进程和 GPU 进程</strong>组成的，渲染内核就是渲染进程。</p><p>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</p><p>设计现代浏览器体系架构时，将浏览器划分为不同的进程是为了增加其稳定性。虽然设计成了多进程架构，不过这些模块之间的沟通方式却有些复杂，也许你还有以下问题：</p><ul><li><p><strong>为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？</strong></p></li><li><p><strong>为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？</strong></p></li></ul><p>通过以上方式不是增加了工程的复杂度吗？</p><p>要解释现代浏览器为什么要把这个流程弄得这么复杂，我们就得从系统安全的角度来分析。</p><h3 id="安全沙箱" tabindex="-1">安全沙箱 <a class="header-anchor" href="#安全沙箱" aria-label="Permalink to &quot;安全沙箱&quot;">​</a></h3><p>需要在渲染进程和操作系统之间建一道墙，<strong>即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限</strong>。将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。</p><p><strong>安全沙箱最小的保护单位是进程</strong>。<strong>因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的</strong>，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。</p><h3 id="安全沙箱如何影响各个模块功能" tabindex="-1">安全沙箱如何影响各个模块功能 <a class="header-anchor" href="#安全沙箱如何影响各个模块功能" aria-label="Permalink to &quot;安全沙箱如何影响各个模块功能&quot;">​</a></h3><p>了解了被安全沙箱保护的进程会有一系列的受限操作之后，接下来我们就可以分析渲染进程和浏览器内核各自都有哪些职责，如下图：</p><img src="https://static001.geekbang.org/resource/image/f8/1b/f8cc6394832ed238f18a01eff5726f1b.png?wh=1142*736" width="600">',14)]))}const f=a(s,[["render",n]]);export{l as __pageData,f as default};
