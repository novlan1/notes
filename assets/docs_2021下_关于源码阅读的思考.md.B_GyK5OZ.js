import{_ as o,c as a,o as c,a2 as d}from"./chunks/framework.CriqKoQt.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2021下/关于源码阅读的思考.md","filePath":"docs/2021下/关于源码阅读的思考.md","lastUpdated":1769935797000}'),r={name:"docs/2021下/关于源码阅读的思考.md"};function t(p,e,n,l,s,i){return c(),a("div",null,e[0]||(e[0]=[d('<h2 id="一、开始" tabindex="-1">一、开始 <a class="header-anchor" href="#一、开始" aria-label="Permalink to &quot;一、开始&quot;">​</a></h2><p>最近几个月看的源码比较多，记录下一些当下的理解。</p><h2 id="二、为什么要阅读源码" tabindex="-1">二、为什么要阅读源码 <a class="header-anchor" href="#二、为什么要阅读源码" aria-label="Permalink to &quot;二、为什么要阅读源码&quot;">​</a></h2><p>个人阅读源码的动机主要是好奇心，好奇<code>babel</code>究竟是如何转化JS的、<code>vue-loader</code>内部究竟做了什么，再深入一点，<code>webpack</code>的架构是什么，<code>webpack</code>和<code>rollup</code>打包原理是不是一样的、有什么不同？</p><p>阅读别人的文章终究不深刻，另外你也不知道他说的对不对，虽然一套套的，但很有可能别人的文章已经过时了。</p><p><code>webpack</code>的<code>tree-shaking</code>是很好的例子，很多文章讲的某些案例不能实现<code>tree-shaking</code>，但<code>webpack</code>最新版本可能并不是这样。想一想原因，<code>tree-shaking</code>不生效的原因是因为静态解析不完备、副作用不能排除，当解决了这个问题，就可以更好的进行<code>tree-shaking</code>。</p><h2 id="三、怎么阅读源码" tabindex="-1">三、怎么阅读源码 <a class="header-anchor" href="#三、怎么阅读源码" aria-label="Permalink to &quot;三、怎么阅读源码&quot;">​</a></h2><p>如果一个框架有自己的文档的话，首先要读下它的文档，因为它的难度比较低，而且文档中也有对其核心功能、核心API的详细说明，读源码的时候可以重点看下这些对外的接口是怎样实现的。</p><p>另外，阅读某些源码可能需要一点门槛，通常是基础知识，比如<code>@babel/core</code>中广泛用的<code>generator</code>和<code>gensync</code>、<code>webpack</code>中用到的<code>tapable</code>插件，对这些前置知识不熟悉的话需要补齐。</p><p>阅读源码过程中，应该抓住主流程。为什么呢？因为分支可能比你想象中要多，如果一开始就把精力放在每一个分支上，估计很快就放弃。当你对主流程掌握后，然后再阅读感兴趣的细节部分，应该是一个更好的选择。</p><p>阅读过程中，在思想层面上，一定要多思考、多对比，想一下为什么这样实现，有什么好处，为什么不那样实现，是不是有更好的实现方式。还可以对比一下与它类似的框架有什么不同，是什么原因造成了这种不同。</p><p>在方法层面上，至少是<code>clone</code>下来，<code>build/dev</code>下、自己跑一下，写几个<code>demo</code>。另外，<code>debug</code>调试、<code>console</code>打印关键信息、画流程图辅助都是有用的。</p><p>读研究生时，一个老师说搞科研要“求源求新”，这句话放到读源码上也适用。”求源“就是看它第一次<code>commit</code>是怎样的、<code>v1.0.0</code>是怎样的，它最开始是为了解决什么问题而出现的。”求新“就是看它最新的版本是怎样的，架构有什么改动，加入了什么新的特性。</p><p>当你对某个框架有自己的感悟时，可以尝试写一篇文章。自己会和写出来是不一样的，在写的过程中，极有可能发现自己对某些知识点掌握得并不深刻，你需要说服自己，然后才能说服别人。</p><h2 id="四、阅读源码的好处" tabindex="-1">四、阅读源码的好处 <a class="header-anchor" href="#四、阅读源码的好处" aria-label="Permalink to &quot;四、阅读源码的好处&quot;">​</a></h2><p>一个很重要的好处是拓宽技术视野，即知识的广度和深度。有意思的是，阅读源码可以兼得广度和深度。深度指的是你都阅读源码了，都在学习原理了，还不深吗？广度指的是阅读过程中遇到的其他知识点，比如<code>@babel/parser</code>中对<code>unicode</code>的运用，还有上面提到的<code>gensync</code>，广度的根本原因是很多框架都是站在巨人的肩膀上的。</p><p>拓宽技术视野又有什么好处呢？其实就跟“读万卷书，行万里路”一样，首先，当工作中遇到类似问题时，你可能会想到与之前不一样的解决办法，其次，当你想自己写一个框架来解决某个问题时，你可能会有较多的思路和想法。</p><h2 id="五、什么是技术强" tabindex="-1">五、什么是技术强 <a class="header-anchor" href="#五、什么是技术强" aria-label="Permalink to &quot;五、什么是技术强&quot;">​</a></h2><p>参考<a href="https://www.zhihu.com/question/456527668/answer/1858291784" target="_blank" rel="noreferrer">尤雨溪的回答</a>，强可以理解为制造影响力的能力，影响力的本质来自于解决问题。如果一个领域的问题被解决得差不多了，那么在这个领域制造影响力的难度就大了许多。要想影响力大，要发现问题，并思考什么才是值得解决的问题，另外具备高质量的解决问题的技术水准。</p>',19)]))}const b=o(r,[["render",t]]);export{_ as __pageData,b as default};
