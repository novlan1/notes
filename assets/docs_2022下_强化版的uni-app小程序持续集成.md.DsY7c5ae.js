import{_ as a,c as i,o as l,ag as n}from"./chunks/framework.6d7lLjym.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2022下/强化版的uni-app小程序持续集成.md","filePath":"docs/2022下/强化版的uni-app小程序持续集成.md","lastUpdated":1754272910000}'),e={name:"docs/2022下/强化版的uni-app小程序持续集成.md"};function p(t,s,h,r,k,d){return l(),i("div",null,s[0]||(s[0]=[n(`<h2 id="_1-开始" tabindex="-1">1. 开始 <a class="header-anchor" href="#_1-开始" aria-label="Permalink to &quot;1. 开始&quot;">​</a></h2><p>最近做了小程序的持续集成相关的工作，主要解决了以下痛点：</p><ol><li>构建时间长，流程繁琐</li><li>外部开发人员无法预览</li></ol><p>本次CI功能点如下：</p><ol><li>自动进行uni-app打包，打包两份：test和release环境</li><li>将打包产物自动上传</li><li>自动预览、生成图片</li><li>将预览图片上传到腾讯云</li><li>发送构建通知、腾讯云图片地址到企业微信</li></ol><h2 id="_2-优化点" tabindex="-1">2. 优化点 <a class="header-anchor" href="#_2-优化点" aria-label="Permalink to &quot;2. 优化点&quot;">​</a></h2><p>相比普通的CI，本次优化点有以下几个。</p><h3 id="_2-1-多环境区分" tabindex="-1">2.1. 多环境区分 <a class="header-anchor" href="#_2-1-多环境区分" aria-label="Permalink to &quot;2.1. 多环境区分&quot;">​</a></h3><p>对于开发版，同一个开发者只能保留一份，当我们既想看测试环境，又想看正式环境时就捉襟见肘了。</p><p>借助小程序ci，对多个环境用不同的机器人，这样就不会覆盖了。</p><h3 id="_2-2-配置驱动" tabindex="-1">2.2. 配置驱动 <a class="header-anchor" href="#_2-2-配置驱动" aria-label="Permalink to &quot;2.2. 配置驱动&quot;">​</a></h3><p>由于小程序ci机器人范围有限（1-30），所以只能手动维护，让其重复利用。</p><p>这里我让项目每个分支每个环境分别对应一个机器人，当一个分支废弃后，这个机器人就可以释放给其他分支使用。</p><p>另外，<code>develop</code>、<code>release</code>这两个分支是不会废弃的，其对应的机器人是固定的，可以体现在流水线中，如：</p><ul><li>wx_ci__esports_11__release__test</li><li>wx_ci__esports_12__release__release</li><li>wx_ci__esports_13__develop__test</li><li>wx_ci__esports_14__develop__release</li></ul><p>为什么不让最重要的<code>release</code>分支的机器人序号为1呢？因为1是默认机器人的位置，这会导致<code>release</code>版本很容易被覆盖。</p><p>同时其他配置项也可以统一保管起来，比如腾讯云密钥、小程序密钥等，方便维护。</p><h3 id="_2-3-自动重试" tabindex="-1">2.3. 自动重试 <a class="header-anchor" href="#_2-3-自动重试" aria-label="Permalink to &quot;2.3. 自动重试&quot;">​</a></h3><p>有时候上传或者预览会失败，可能是环境问题，也可能是多个流水线同时上传会冲突，因为需要增加自动重试功能。</p><h3 id="_2-4-并行提速" tabindex="-1">2.4. 并行提速 <a class="header-anchor" href="#_2-4-并行提速" aria-label="Permalink to &quot;2.4. 并行提速&quot;">​</a></h3><p>上传和预览是可以同步进行的，这样可以节省一些构建时间。</p><h3 id="_2-5-canvas绘图" tabindex="-1">2.5. canvas绘图 <a class="header-anchor" href="#_2-5-canvas绘图" aria-label="Permalink to &quot;2.5. canvas绘图&quot;">​</a></h3><p>小程序ci默认提供的图片只有二维码，笔者用canvas将一些构建信息和二维码绘制到一张新图上，方便定位和查看。</p><p>绘制的信息示例：</p><ul><li>版本号：1.0.5</li><li>提交者：CI机器人5</li><li>环境：test</li><li>分支：release</li><li>构建时间：2022-10-19: 09:36:37</li><li>最后提交：lee - 修复page</li><li>二维码</li></ul><h3 id="_2-6-定时执行" tabindex="-1">2.6. 定时执行 <a class="header-anchor" href="#_2-6-定时执行" aria-label="Permalink to &quot;2.6. 定时执行&quot;">​</a></h3><p>由于开发版二维码存在有效期，这里加了个定时执行，这样可以保持二维码最新，不会失效。</p><h2 id="_3-其他" tabindex="-1">3. 其他 <a class="header-anchor" href="#_3-其他" aria-label="Permalink to &quot;3. 其他&quot;">​</a></h2><h3 id="_3-1-canvas" tabindex="-1">3.1. canvas <a class="header-anchor" href="#_3-1-canvas" aria-label="Permalink to &quot;3.1. canvas&quot;">​</a></h3><p>canvas版本需要和node版本匹配才可以，否则会报一些奇奇怪怪的错，这里直接在CI中安装对应的canvas版本，并用bash脚本调用js脚本的方式来解决。部分代码如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $WORKSPACE</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;VUE_APP_AUTHOR = CI ROBOT \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">robot</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.env.local</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">// ...</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tmp-mp-ci.js</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> miniprogram-ci</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> canvas@2.6.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> t-comm@latest</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --registry=https://registry.npmjs.org/</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [[ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">env</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;production&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]]; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build:mp:prod</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build:mp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fi</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tmp-mp-ci.js</span></span></code></pre></div><h3 id="_3-2-变量传递问题" tabindex="-1">3.2. 变量传递问题 <a class="header-anchor" href="#_3-2-变量传递问题" aria-label="Permalink to &quot;3.2. 变量传递问题&quot;">​</a></h3><p>流水线中nodejs脚本中获取CI变量十分容易，只需要<code>\${env}</code>即可。</p><p>但是一个普通的打包时才会运行的nodejs脚本，如何获得CI变量呢？</p><p>可以把CI变量写到环境变量文件中，比如<code>.env.local</code>，然后打包时读取这个文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CI变量 =&gt; 写入环境变量文件 =&gt; 打包时读取文件</span></span></code></pre></div><h3 id="_3-3-qq小程序体验版" tabindex="-1">3.3. qq小程序体验版 <a class="header-anchor" href="#_3-3-qq小程序体验版" aria-label="Permalink to &quot;3.3. qq小程序体验版&quot;">​</a></h3><p>QQ小程序可以在ci中设置体验版，如何用实例的方式控制呢？</p><p>如果单独建一个专门的非实例化的流水线，维护成本会变高，这里可以复制下上个步骤，复制的job只更改一个地方——设置体验版，然后用流水线变量控制。</p><h3 id="_3-4-扩展性" tabindex="-1">3.4. 扩展性 <a class="header-anchor" href="#_3-4-扩展性" aria-label="Permalink to &quot;3.4. 扩展性&quot;">​</a></h3><p>这里讨论下本CI的扩展性，当有新项目接入时，只需要做：</p><ol><li>增加一条新的配置</li><li>实例化新项目的流水线</li></ol><p>可以看到，非常简单。</p><p>当原有项目更新时，或者CI框架变动时，只需要做：</p><ol><li>更新配置</li><li>CI命令更新</li></ol>`,45)]))}const F=a(e,[["render",p]]);export{c as __pageData,F as default};
