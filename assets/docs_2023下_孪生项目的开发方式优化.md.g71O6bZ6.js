import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.6d7lLjym.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2023下/孪生项目的开发方式优化.md","filePath":"docs/2023下/孪生项目的开发方式优化.md","lastUpdated":1746156232000}'),l={name:"docs/2023下/孪生项目的开发方式优化.md"};function p(t,s,h,d,o,k){return e(),a("div",null,s[0]||(s[0]=[n(`<h2 id="_1-开始" tabindex="-1">1. 开始 <a class="header-anchor" href="#_1-开始" aria-label="Permalink to &quot;1. 开始&quot;">​</a></h2><p>何为孪生项目？故名思义，就是两个项目长得很像，比如项目<code>A</code>和项目<code>A+</code>，项目<code>A+</code>从项目<code>A</code>衍生而来，二者有些功能差异，但差异度很小，低于10%。</p><p>除了业务上的这种场景，还有其他情况会产生孪生项目，比如开源项目，如果对内和对外的开源程度不同，或者功能有差异，也会形成孪生项目。</p><p>这里不去讨论产品层面的逻辑，也不去讨论拆分为两个项目是否合理，仅讨论如何更高效的开发此类的项目。</p><h2 id="_2-刀耕火种" tabindex="-1">2. 刀耕火种 <a class="header-anchor" href="#_2-刀耕火种" aria-label="Permalink to &quot;2. 刀耕火种&quot;">​</a></h2><p>最原始的方式就是在项目<code>A</code>上开发后，将代码搬运到项目<code>A+</code>上，此种方式开发时十分痛苦，痛苦点如下：</p><ul><li>开发效率低，一模一样的代码需要写两遍</li><li>存在遗漏风险，开发周期稍长时很可能发生</li><li>存在错误风险，有可能粘贴错位置</li><li>存在冲突风险，有可能与他人改动冲突</li></ul><p>同步代码的频率也很高，包括以下场景：</p><ul><li>需求迭代</li><li>bug修复</li><li>重构、优化代码</li></ul><p>另外，业务自身就比较复杂，这种开发方式更加剧了项目的复杂性，不利于后期维护。</p><h2 id="_3-工具化" tabindex="-1">3. 工具化 <a class="header-anchor" href="#_3-工具化" aria-label="Permalink to &quot;3. 工具化&quot;">​</a></h2><p>既然原始方式弊端如此多，如何改进呢？</p><h3 id="_3-1-思路及实现" tabindex="-1">3.1. 思路及实现 <a class="header-anchor" href="#_3-1-思路及实现" aria-label="Permalink to &quot;3.1. 思路及实现&quot;">​</a></h3><p>可以用工具自动化的同步代码，这里的实现思路如下：</p><ul><li>条件编译解决差异部分</li><li>以页面为单位，将每个差异部分控制在几行内，也就是封装组件、方法</li><li>用脚本同步代码，从页面开始，递归分析依赖，一起同步</li></ul><p>这里面有几个前提：</p><ol><li>项目<code>A</code>和项目<code>A+</code>的差异点不能太多，如果异大于同，可以另起炉灶，用新路由，公共部分封装中间层</li><li>公共组件、方法需保证一致，包括: <ul><li>三方库，比如<code>press-ui</code></li><li><code>common</code></li><li><code>component</code></li></ul></li></ol><p>对于 <code>store</code>、全局<code>mixin</code>、<code>local-component</code>下的公共组件，比如<code>header</code>，也建议保持一致，如果确实无法保持一致，也可以解决，可以用工具<code>ignore</code>字段排除，或者让同步文件的粒度变细一点。</p><p>另外，这种工具是利用了<code>uni-app</code><a href="https://uniapp.dcloud.net.cn/collocation/package.html" target="_blank" rel="noreferrer">扩展平台</a>的能力，国际化也是这么做的。</p><h3 id="_3-2-使用方式" tabindex="-1">3.2. 使用方式 <a class="header-anchor" href="#_3-2-使用方式" aria-label="Permalink to &quot;3.2. 使用方式&quot;">​</a></h3><p>在项目根目录下增加文件<code>light-cli.config.js</code>，内容如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;sync-repo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    target: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;../pro&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ignore: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;src/common/**/*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;src/component/**/*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    files: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;src/project/user/views/message-center/message-center-index.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;src/project/user/views/message-center/message-center-detail.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>然后执行:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> light-cli</span></span></code></pre></div><p>注意<code>files</code>不一定是页面，如果想同步某个底层文件也可以，工具足够灵活，可以支持任意粒度的文件。</p><p>工具地址<a href="https://github.com/novlan1/uni-plugin-light/tree/master/task" target="_blank" rel="noreferrer">在这里</a>。</p><h3 id="_3-3-可能引起的问题" tabindex="-1">3.3. 可能引起的问题 <a class="header-anchor" href="#_3-3-可能引起的问题" aria-label="Permalink to &quot;3.3. 可能引起的问题&quot;">​</a></h3><p>此外，使用扩展条件编译发现一个坑点，在三方库<code>ts</code>文件中用条件编译，包裹<code>import</code>语句时，在小程序平台，顶部的<code>#ifdef</code>会被去掉。</p><p>比如下面这段代码，<code>#ifdef H5</code>会被去掉，导致编译出错。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// handler.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { dialogProps } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./computed&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #ifdef H5</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VueDialog </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./press-dialog.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #endif</span></span></code></pre></div><h2 id="_4-效果" tabindex="-1">4. 效果 <a class="header-anchor" href="#_4-效果" aria-label="Permalink to &quot;4. 效果&quot;">​</a></h2><p>使用这种方式可以大大提高生产力，提升开发效率。并且，工具比人更能减少出错的可能，减少bug。</p><p>更重要的是，关注点会更加聚焦，只关心“主”项目，“从”项目只需要看下每次脚本跑的差异即可，这里主从关系并不是固定的，二者可互换。</p>`,33)]))}const E=i(l,[["render",p]]);export{c as __pageData,E as default};
