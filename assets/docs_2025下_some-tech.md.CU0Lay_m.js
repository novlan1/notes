import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.6d7lLjym.js";const r=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2025下/some-tech.md","filePath":"docs/2025下/some-tech.md","lastUpdated":1764089547000}'),l={name:"docs/2025下/some-tech.md"};function p(n,s,o,h,d,c){return e(),a("div",null,s[0]||(s[0]=[t(`<p>在 React 函数组件中，每一次 UI 的变化，都是通过重新执行整个函数来完成的，这和传统的 Class 组件有很大区别：函数组件中并没有一个直接的方式在多次渲染之间维持一个状态。</p><hr><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">brew</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cairo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pango</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> libpng</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jpeg</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> giflib</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> librsvg</span></span></code></pre></div><p><a href="https://github.com/Automattic/node-canvas/issues/1825" target="_blank" rel="noreferrer">https://github.com/Automattic/node-canvas/issues/1825</a></p><p>安装失败 node-pre-gyp install --fallback-to-build --update-binary</p><hr><p>想拷贝目录里面的内容而不是目录本身，就用斜杠加个星号 <code>cp –R src/* target</code>，想拷贝目录本身，就啥也不带 <code>cp –R src target</code> 就行了。</p><p>前者会变成 <code>target/file1、target/file2</code>，后者会变成 <code>target/src</code>。</p><hr><ol><li><code>$uri</code> nginx 中的 <code>$uri</code> 记录的是执行一系列内部重定向操作后最终传递到后端服务器的 URL</li></ol><p>包含请求的文件名和路径，不包含包含“?”或“#”等参数。</p><p>比如，完整URL链接：<code>http://www.alipay.com/alipay/index.html</code>，对应的 <code>$uri</code>：<code>/alipay/index.html</code></p><ol start="2"><li><code>$request_uri</code><code>$request_uri</code> 记录的是当前请求的原始URL（包含参数），如果没有执行内部重定向操作，<code>request_uri</code> 去掉参数后的值和 <code>uri</code> 的值是一样的。在线上环境中排查问题是，如果在后端服务器中看到的请求和 Nginx 中存放的 <code>request_uri</code> 无法匹配，可以考虑去uri里边进行查找。</li></ol><p>包含请求的文件名和路径及所有参数</p><p>比如，完整URL链接：<code>http://www.alipay.com/alipay/index.html</code>，<code>$request_uri</code>：<code>/alipay/index.html#参数</code></p><hr><p>依赖预构建有两个目的:</p><ol><li>CommonJS 和 UMD 兼容性: 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。</li></ol><p>当转换 CommonJS 依赖时，Vite 会执行智能导入分析，这样即使导出是动态分配的（如 React），按名导入也会符合预期效果：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 符合预期</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span></span></code></pre></div><ol start="2"><li>性能： Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</li></ol><p>一些包将它们的 ES 模块构建作为许多单独的文件相互导入。例如，lodash-es 有超过 600 个内置模块！当我们执行 import { debounce } from &#39;lodash-es&#39; 时，浏览器同时发出 600 多个 HTTP 请求！尽管服务器在处理这些请求时没有问题，但大量的请求会在浏览器端造成网络拥塞，导致页面的加载速度相当慢。</p><p>通过预构建 <code>lodash-es</code> 成为一个模块，我们就只需要一个 HTTP 请求了！</p><hr><p>定位兼容性问题，可以直接把 <code>vconsole</code> 放到 <code>index.html</code> 中，看看错误日志</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://image-1251917893.file.myqcloud.com/igame/npm/vconsole%403.15.1/vconsole.min.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // VConsole will be exported to \`window.VConsole\` by default.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vConsole </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">VConsole</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><hr><p><code>globalThis</code> 的 <code>polyfill</code> 和其他变量不一样，它自己本身是顶级变量，每个上下文都需要单独 <code>polyfill</code>，更好的做法是不用它。</p><hr><p><code>input</code> 标签 ，<code>type=&quot;number&quot;</code> 时，<code>value</code> 不能传递 <code>null</code>，否则会被 uni-app 过滤</p><hr>`,31)]))}const g=i(l,[["render",p]]);export{r as __pageData,g as default};
