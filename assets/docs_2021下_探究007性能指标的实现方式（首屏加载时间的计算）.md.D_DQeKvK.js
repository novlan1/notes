import{_ as a,c as o,o as n,ag as i}from"./chunks/framework.6d7lLjym.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2021下/探究007性能指标的实现方式（首屏加载时间的计算）.md","filePath":"docs/2021下/探究007性能指标的实现方式（首屏加载时间的计算）.md","lastUpdated":1763086797000}'),t={name:"docs/2021下/探究007性能指标的实现方式（首屏加载时间的计算）.md"};function r(l,e,s,d,c,p){return n(),o("div",null,e[0]||(e[0]=[i(`<h3 id="一、performance-对象" tabindex="-1">一、Performance 对象 <a class="header-anchor" href="#一、performance-对象" aria-label="Permalink to &quot;一、Performance 对象&quot;">​</a></h3><p><a href="https://007.a.com/v2/data-query" target="_blank" rel="noreferrer">007</a>性能指标是利用了<code>Performance</code>对象，可以通过<code>window.performance</code>获取<code>Performance</code>。</p><p><code>Performance</code>可以获得性能数据(<code>timing</code>)、内存数据(<code>memory</code>)等。这里仅介绍<code>performance.timing</code>属性，其他 API 可参阅后面的链接。</p><p>下面按照触发顺序看一下各个属性的含义。</p><img src="http://doc.uwayfly.com/performance-timing.png" width="900"><h4 id="_1-prompt-for-unload-上一个页面卸载" tabindex="-1">1. <code>prompt for unload</code> 上一个页面卸载 <a class="header-anchor" href="#_1-prompt-for-unload-上一个页面卸载" aria-label="Permalink to &quot;1. \`prompt for unload\` 上一个页面卸载&quot;">​</a></h4><ul><li><code>navigationStart</code>：在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）<code>unload</code> 的时间戳，如果无前一个网页 unload ，则与 <code>fetchStart</code> 值相等</li><li><code>unloadEventStart</code>：前一个网页（与当前页面同域）<code>unload </code>的时间戳，如果无前一个网页 <code>unload</code> 或者前一个网页与当前页面不同域，则值为 0</li><li><code>unloadEventEnd</code>：和 <code>unloadEventStart</code> 相对应，返回前一个网页 <code>unload</code> 事件绑定的回调函数执行完毕的时间戳</li></ul><h4 id="_2-重定向" tabindex="-1">2. 重定向 <a class="header-anchor" href="#_2-重定向" aria-label="Permalink to &quot;2. 重定向&quot;">​</a></h4><ul><li><code>redirectStart</code>：第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0</li><li><code>redirectEnd</code>：最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内的重定向才算，否则值为 0</li><li><code>fetchStart</code>：浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前</li></ul><h4 id="_3-dns解析" tabindex="-1">3. DNS解析 <a class="header-anchor" href="#_3-dns解析" aria-label="Permalink to &quot;3. DNS解析&quot;">​</a></h4><ul><li><code>domainLookupStart</code>：DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 <code>fetchStart</code> 值相等</li><li><code>domainLookupEnd</code>：DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 <code>fetchStart</code> 值相等</li></ul><h4 id="_4-tcp三次握手" tabindex="-1">4. TCP三次握手 <a class="header-anchor" href="#_4-tcp三次握手" aria-label="Permalink to &quot;4. TCP三次握手&quot;">​</a></h4><ul><li><code>connectStart</code>：HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 <code>fetchStart</code> 值相等，如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间</li><li><code>connectEnd</code>：HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 <code>fetchStart</code> 值相等，如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间</li><li><code>secureConnectionStart</code>：HTTPS 连接开始的时间，如果不是安全连接，则值为 0</li></ul><h4 id="_5-请求数据" tabindex="-1">5. 请求数据 <a class="header-anchor" href="#_5-请求数据" aria-label="Permalink to &quot;5. 请求数据&quot;">​</a></h4><ul><li><code>requestStart</code>：HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存，连接错误重连时，这里显示的也是新建立连接的时间</li><li><code>responseStart</code>：HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存</li><li><code>responseEnd</code>：HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存</li></ul><h4 id="_6-processing-js执行、dom解析渲染" tabindex="-1">6. <code>processing</code>，JS执行、DOM解析渲染 <a class="header-anchor" href="#_6-processing-js执行、dom解析渲染" aria-label="Permalink to &quot;6. \`processing\`，JS执行、DOM解析渲染&quot;">​</a></h4><ul><li><code>domLoading</code>：开始解析渲染 DOM 树的时间，此时 <code>Document.readyState</code> 变为 <code>loading</code>，并将抛出 <code>readystatechange</code> 相关事件</li><li><code>domInteractive</code>：完成解析 DOM 树的时间，<code>Document.readyState</code> 变为 <code>interactive</code>，并将抛出 <code>readystatechange</code> 相关事件</li><li><code>domContentLoadedEventStart</code>：DOM 解析完成后，网页内资源加载开始的时间，文档发生 <code>DOMContentLoaded</code>事件的时间</li><li><code>domContentLoadedEventEnd</code>：DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕），文档的<code>DOMContentLoaded</code> 事件的结束时间</li><li><code>domComplete</code>：DOM 树解析完成，且资源也准备就绪的时间，<code>Document.readyState</code> 变为 <code>complete</code>，并将抛出 <code>readystatechange</code> 相关事件</li></ul><h4 id="_7-load事件开始" tabindex="-1">7. <code>load</code>事件开始 <a class="header-anchor" href="#_7-load事件开始" aria-label="Permalink to &quot;7. \`load\`事件开始&quot;">​</a></h4><ul><li><code>loadEventStart</code>：<code>load</code> 事件发送给文档，也即 <code>load</code> 回调函数开始执行的时间，如果没有绑定 <code>load</code> 事件，值为 0</li><li><code>loadEventEnd</code>：<code>load</code> 事件的回调函数执行完毕的时间，如果没有绑定 <code>load</code> 事件，值为 0</li></ul><p>看完上面的属性，是不是有似曾相识的感觉，就是那个常见的问题&quot;浏览器输入一个URL会依次发生什么&quot;，只不过<code>performance</code>精确获取了这些时间。</p><h3 id="二、007性能指标" tabindex="-1">二、007性能指标 <a class="header-anchor" href="#二、007性能指标" aria-label="Permalink to &quot;二、007性能指标&quot;">​</a></h3><p>在<a href="https://git.a.com/TNTWeb/opensource/emonitor/emonitor/blob/master/src/performance/index.js" target="_blank" rel="noreferrer">源码</a>中可以看到007性能指标的计算方法。007的性能指标包括：</p><ol><li>DNS 连接耗时</li><li>TCP连接耗时</li><li>后端响应时间</li><li>HTML 页面下载时间</li><li>DOM 时间</li><li>首次加载耗时</li><li>整页耗时</li><li>解析 DOM 树耗时</li></ol><p>它们的计算方式如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>timeOrigin = performance.wx.timeOrigin || performance.timing.fetchStart</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1. DNS 连接耗时：domainLookupEnd - domainLookupStart;</span></span>
<span class="line"><span>2. TCP 连接耗时：connectEnd - connectStart;</span></span>
<span class="line"><span>3. 后端响应时间：responseStart - requestStart</span></span>
<span class="line"><span>4. HTML 页面下载时间： responseEnd - responseStart</span></span>
<span class="line"><span>5. DOM 时间：domContentLoadedEventStart - responseEnd</span></span>
<span class="line"><span>6. 首屏时间（首次加载耗时）：domLoading - timeOrigin</span></span>
<span class="line"><span>7. 首页时间（整页耗时）： loadEventEnd - timeOrigin</span></span>
<span class="line"><span>8. 解析 DOM 树耗时： domComplete - domInteractive</span></span></code></pre></div><p><code>performance.timing</code>即将被废弃，取而代之的是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceNavigationTiming" target="_blank" rel="noreferrer"><code>PerformanceNavigationTiming</code></a>，绝大部分 API 是差不多的，只是后者换成了相对时间，前者是时间戳，即绝对时间。</p><p>可以试试下面的代码：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showNavigationDetails</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Get the first entry</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEntriesByType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;navigation&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Show it in a nice table in the developer console</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(entry.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toJSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showNavigationDetails</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="三、相关问题" tabindex="-1">三、相关问题 <a class="header-anchor" href="#三、相关问题" aria-label="Permalink to &quot;三、相关问题&quot;">​</a></h3><h4 id="_1、对于vue这样的单页应用-路由跳转后的页面加载会另外计算吗" tabindex="-1">1、对于Vue这样的单页应用，路由跳转后的页面加载会另外计算吗？ <a class="header-anchor" href="#_1、对于vue这样的单页应用-路由跳转后的页面加载会另外计算吗" aria-label="Permalink to &quot;1、对于Vue这样的单页应用，路由跳转后的页面加载会另外计算吗？&quot;">​</a></h4><p>不会。路由跳转不会触发<code>unload</code>事件。另外，试验也发现，跳转后的页面打印的<code>performance</code>的<code>domloing</code>、<code>fetchStart</code>的时间与上一页面相同。</p><p>所以对跳转后的页面做的优化并不会影响到首屏的时间，比如对二次页面的预加载等手段。</p><h4 id="_2、不同工具的首屏时间不一致" tabindex="-1">2、不同工具的首屏时间不一致？ <a class="header-anchor" href="#_2、不同工具的首屏时间不一致" aria-label="Permalink to &quot;2、不同工具的首屏时间不一致？&quot;">​</a></h4><p>这很常见。首屏时间的计算方式有多种，有的人用<a href="https://www.cnblogs.com/longm/p/7382163.html" target="_blank" rel="noreferrer">加载最慢的图片的时间点 - navigationStart</a>，有的人用<a href="https://juejin.cn/post/6844904112107044872" target="_blank" rel="noreferrer">加载最慢的图片的时间点 - loadEventStart</a>，还有的会<a href="https://juejin.cn/post/6928739992986615816" target="_blank" rel="noreferrer">区分SSR和SPA应用</a>。</p><p>首屏时间指的是浏览器显示第一屏页面所消耗的时间，包含了DNS解析、TCP握手、资源加载、DOM解析等时间，只要能囊括这些时间的指标都可以使用，毕竟使用中更多的是横向对比和纵向对比，而不是对比指标数据本身。</p><h4 id="_3、-如何减少首屏时间" tabindex="-1">3、 如何减少首屏时间？ <a class="header-anchor" href="#_3、-如何减少首屏时间" aria-label="Permalink to &quot;3、 如何减少首屏时间？&quot;">​</a></h4><p>从首屏的概念和其包含的阶段可以看出，只要能减少其中包含步骤的时间，就能降低首屏时间。</p><p>常用方法包括：</p><ul><li>图片和JS的懒加载、按需加载</li><li>使用CDN资源</li><li>文件压缩和合并</li><li>使用http2</li><li>使用缓存</li></ul><h3 id="四、相关资料" tabindex="-1">四、相关资料 <a class="header-anchor" href="#四、相关资料" aria-label="Permalink to &quot;四、相关资料&quot;">​</a></h3><ol><li><a href="https://git.a.com/TNTWeb/opensource/emonitor/emonitor/blob/master/src/performance/index.js" target="_blank" rel="noreferrer">007-Performance</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance" target="_blank" rel="noreferrer">MDN-Performance</a></li><li><a href="https://w3c.github.io/navigation-timing/#introduction" target="_blank" rel="noreferrer">W3C Editor&#39;s Draft</a></li><li><a href="https://www.cnblogs.com/bldxh/p/6857324.html" target="_blank" rel="noreferrer">Performance — 前端性能监控利器</a></li><li><a href="https://juejin.cn/post/6844903801518981133#heading-23" target="_blank" rel="noreferrer">性能优化篇 - Performance（工具 &amp; api）</a></li><li><a href="https://blog.csdn.net/qq_28387069/article/details/112243319" target="_blank" rel="noreferrer">JS：Performance</a></li><li><a href="https://www.cnblogs.com/longm/p/7382163.html" target="_blank" rel="noreferrer">前端优化-如何计算白屏和首屏时间</a></li><li><a href="https://juejin.cn/post/6961308860103524360" target="_blank" rel="noreferrer">前端首屏优化</a></li><li><a href="https://juejin.cn/post/6888924324137926669" target="_blank" rel="noreferrer">前端性能指标{Performance}</a></li></ol>`,41)]))}const k=a(t,[["render",r]]);export{m as __pageData,k as default};
