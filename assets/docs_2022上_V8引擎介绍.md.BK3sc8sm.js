import{_ as i,c as a,o as n,a2 as t}from"./chunks/framework.CriqKoQt.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2022上/V8引擎介绍.md","filePath":"docs/2022上/V8引擎介绍.md","lastUpdated":1769657770000}'),e={name:"docs/2022上/V8引擎介绍.md"};function h(l,s,p,k,r,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h2 id="一、开始" tabindex="-1">一、开始 <a class="header-anchor" href="#一、开始" aria-label="Permalink to &quot;一、开始&quot;">​</a></h2><p>本文介绍了编译、解释、动静态语言等基本概念，以及 V8 引擎的基本流程。</p><h2 id="二、编译与解释" tabindex="-1">二、编译与解释 <a class="header-anchor" href="#二、编译与解释" aria-label="Permalink to &quot;二、编译与解释&quot;">​</a></h2><p>二进制指令就是机器码</p><ul><li>编译：将源代码一次性转换成目标代码的过程。执行编译过程的程序叫编译器（Compiler）。</li><li>解释：将源代码逐条转换成目标代码，同时逐条运行的过程。执行解释过程的程序叫解释器（Interpreter）。解释器一般来说就是 vm，vm 有两种，一种是基于堆栈，一种是基于寄存器。</li></ul><p>编译过程大致包括词法分析、语法分析、语义分析、性能优化、生成可执行文件等五个步骤，期间涉及到复杂的算法和硬件架构。解释器与此类似。</p><h2 id="三、静态语言与动态语言" tabindex="-1">三、静态语言与动态语言 <a class="header-anchor" href="#三、静态语言与动态语言" aria-label="Permalink to &quot;三、静态语言与动态语言&quot;">​</a></h2><p>高级语言按照执行方式的不同，可分为静态语言和动态语言。</p><ul><li>静态语言：使用编译执行的语言，如 C、C++、Golang 等。使用编译器一次性生成目标代码，“一次编译，无限次运行”，程序运行速度更快。编译型语言一般是不能跨平台的，也就是不能在不同的操作系统之间随意切换。</li><li>动态语言：使用解释执行的语言，如 Python、Javascript、PHP 等。执行过程中需要源代码，只要存在解释器，源代码可以在任何操作系统上运行，可移植性好，“一次编写，到处运行”。</li></ul><img src="http://doc.uwayfly.com/computer-base-compiler-interperter.png" width="380"><p>解释型语言之所以能够跨平台，是因为有了解释器这个中间层。在不同的平台下，解释器会将相同的源代码转换成不同的机器码，解释器帮助我们屏蔽了不同平台之间的差异。</p><blockquote><p>java 和 C# 是一种比较奇葩的存在，它们是半编译半解释型的语言，源代码需要先转换成一种中间文件（字节码文件），然后再将中间文件拿到虚拟机中执行。Java 引领了这种风潮，它的初衷是在跨平台的同时兼顾执行效率；C# 是后来的跟随者，但是 C# 一直止步于 Windows 平台，在其它平台鲜有作为。</p></blockquote><p>总结一下：</p><table tabindex="0"><thead><tr><th>类型</th><th>原理</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>编译型语言</td><td>通过专门的编译器，将所有源代码一次性转换成特定平台（Windows、Linux 等）执行的机器码（以可执行文件的形式存在）。</td><td>编译一次后，脱离了编译器也可以运行，并且<strong>运行效率高</strong>。</td><td><strong>可移植性差</strong>，不够灵活。</td></tr><tr><td>解释型语言</td><td>由专门的解释器，根据需要将部分源代码临时转换成特定平台的机器码。</td><td><strong>跨平台性好</strong>，通过不同的解释器，将相同的源代码解释成不同平台下的机器码。</td><td>一边执行一边转换，<strong>效率很低</strong>。</td></tr></tbody></table><h2 id="四、v8引擎" tabindex="-1">四、V8引擎 <a class="header-anchor" href="#四、v8引擎" aria-label="Permalink to &quot;四、V8引擎&quot;">​</a></h2><p>Javascript 是解释型语言，那么 V8 引擎就对应着解释器。但是 V8 引擎为了提高 JS 的运行效率，会提前编译。</p><p>也就是 V8 引擎包括两个阶段：编译、执行，编译阶段指 V8 将 JavaScript 转换为字节码或者二进制机器码，执行阶段指解释器解释执行字节码，或者 CPU 直接执行二进制机器码。</p><h3 id="_1-jit" tabindex="-1">1. JIT <a class="header-anchor" href="#_1-jit" aria-label="Permalink to &quot;1. JIT&quot;">​</a></h3><p>V8 引擎同时采用了解释执行和编译执行这两种方式，也就是在运行时进行编译，这种方式称为 JIT (<code>Just in Time</code>) 即时编译。</p><p>V8 在执行 JavaScript 源码时，会先通过解析器将源码解析成 AST，解释器会将 AST 转化为字节码，一边解释一遍执行。</p><p>解释器同时会记录某一代码片段的执行次数，如果执行次数超过了某个阈值，这段代码便会被标记为热代码(<code>Hot Code</code>)，同时将运行信息反馈给优化编译器 TurboFan，TurboFan 根据反馈信息，会优化并编译字节码，最后生成优化的机器码。</p><h3 id="_2-parser-生成抽象语法树" tabindex="-1">2. Parser 生成抽象语法树 <a class="header-anchor" href="#_2-parser-生成抽象语法树" aria-label="Permalink to &quot;2. Parser 生成抽象语法树&quot;">​</a></h3><p>Parser 生成 AST 抽象语法树过程包括语法分析、词法分析，和 Babel 等工具差不多。</p><p>生成 AST 中的一个优化是惰性解析(Lazy Parsing)，因为源码在执行前如果全部完全解析的话，不仅执行时间过长，而且会消耗更多的内存。</p><blockquote><p>惰性解析就是指如果遇到并不是立即执行的函数，只会对其进行预解析(<code>Pre-Parser</code>)，当函数被调用时，才会对其完全解析。 预解析时，只会验证函数的语法是否有效、解析函数声明以及确定函数作用域，并不会生成 AST，这项工作由 <code>Pre-Parser</code> 预解析器完成。</p></blockquote><h3 id="_3-ignition-生成字节码" tabindex="-1">3. Ignition 生成字节码 <a class="header-anchor" href="#_3-ignition-生成字节码" aria-label="Permalink to &quot;3. Ignition 生成字节码&quot;">​</a></h3><p>字节码是机器码的抽象，可以看作是小型的构建块。相比机器码，字节码不仅占用内存少，而且生成字节码的时间很快，提升了启动速度。</p><p>另外，字节码与特定类型的机器码无关，通过解释器将字节码转换为机器码后才可以执行，这样也使得 V8 更加方便的移植到不同的 CPU 架构。</p><p>可以通过如下命令，查看 JavaScript 代码生成的字节码。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">print</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bytecode index.js</span></span></code></pre></div><p>注意，解释器执行字节码前，还是会将字节码转为机器码，因为计算机只识别机器码。</p><h3 id="_4-turbofan" tabindex="-1">4. TurboFan <a class="header-anchor" href="#_4-turbofan" aria-label="Permalink to &quot;4. TurboFan&quot;">​</a></h3><blockquote><p>Ignition 执行上一步生成的字节码，并记录代码运行的次数等信息，如果同一段代码执行了很多次，就会被标记为 “HotSpot”（热点代码），然后把这段代码发送给 编译器TurboFan。 然后TurboFan把它编译为更高效的机器码储存起来，等到下次再执行到这段代码时，就会用现在的机器码替换原来的字节码进行执行，这样大大提升了代码的执行效率。 另外，当TurboFan判断一段代码不再为热点代码的时候，会执行去优化的过程，把优化的机器码丢掉，然后执行过程回到 Ignition。</p></blockquote><p>TurboFan 做的优化包括内联（<code>inlining</code>）和逃逸分析（<code>Escape Analysis</code>）。</p><p>内联就是将相关联的函数进行合并，减少运行时间。比如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>内联处理后：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fooAddInlined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> addReturnValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> addReturnValue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因为 fooAddInlined 中 a 和 b 的值都是确定的，所以可以进一步优化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fooAddInlined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>逃逸分析就是分析对象的生命周期是否仅限于当前函数，如果是的话会对其进行优化。比如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { x: a, y: b }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.y</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>会处理成：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj_x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj_y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj_x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj_y</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_5-总体流程" tabindex="-1">5. 总体流程 <a class="header-anchor" href="#_5-总体流程" aria-label="Permalink to &quot;5. 总体流程&quot;">​</a></h3><img src="http://doc.uwayfly.com/v8-process.png" width="900"><h2 id="五、相关资料" tabindex="-1">五、相关资料 <a class="header-anchor" href="#五、相关资料" aria-label="Permalink to &quot;五、相关资料&quot;">​</a></h2><ol><li><a href="https://github.com/v8/v8" target="_blank" rel="noreferrer">v8</a></li><li><a href="http://c.biancheng.net/view/4136.html" target="_blank" rel="noreferrer">编译型语言和解释型语言的区别</a></li><li><a href="https://blog.csdn.net/yue_2018/article/details/89143984" target="_blank" rel="noreferrer">编译器与解释器的区别</a></li><li><a href="https://www.zhihu.com/question/53612496" target="_blank" rel="noreferrer">js引擎能做到多小？</a></li><li><a href="https://juejin.cn/post/6996825009280778253" target="_blank" rel="noreferrer">深入理解JS引擎</a></li><li><a href="https://zhuanlan.zhihu.com/p/96502646" target="_blank" rel="noreferrer">V8是如何执行JavaScript代码的？</a></li><li><a href="https://www.zhihu.com/question/19672491" target="_blank" rel="noreferrer">JIT 为什么能大幅度提升性能？</a></li><li><a href="https://blog.csdn.net/c1481118216/article/details/76592289" target="_blank" rel="noreferrer">JIT（just-in-time） 即时编译</a></li></ol>`,46)]))}const c=i(e,[["render",h]]);export{E as __pageData,c as default};
