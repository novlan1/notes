import{_ as e,c as i,o,ag as t}from"./chunks/framework.6d7lLjym.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2024下/Vite版本的组件分发插件.md","filePath":"docs/2024下/Vite版本的组件分发插件.md","lastUpdated":1751532926000}'),a={name:"docs/2024下/Vite版本的组件分发插件.md"};function c(p,l,d,n,r,s){return o(),i("div",null,l[0]||(l[0]=[t('<h2 id="_1-开始" tabindex="-1">1. 开始 <a class="header-anchor" href="#_1-开始" aria-label="Permalink to &quot;1. 开始&quot;">​</a></h2><p>项目由基于 Vue2 的 uni-app 迁移到了 Vue3 的 uni-app，遇到了主包大小的问题。</p><p>原因在于项目模式是“大组件，小页面”，且使用了较多的 <code>npm</code> 包，比如 <code>Press Plus</code> 等。<code>Press Plus</code>、<code>local-component</code>、<code>component</code> 子仓的位置都在分包以外，按照小程序的打包规则（基于目录位置），自然是放到主包的。当使用越来越多的外部组件时，必然会遇到主包过大的问题。</p><p>Vue2 时已经写了基于 Webpack 的组件分发和脚本分发插件，这次来实现 Vite 版本（Vue3）的组件分发插件，脚本分发插件后面看情况再开发。</p><h2 id="_2-思路" tabindex="-1">2. 思路 <a class="header-anchor" href="#_2-思路" aria-label="Permalink to &quot;2. 思路&quot;">​</a></h2><p>把大象放进冰箱，需要3步：</p><ol><li>打开冰箱门</li><li>把大象放进去</li><li>关闭冰箱门</li></ol><p>组件分发比上面简单，需要2步：</p><ol><li>找到需要分发的组件</li><li>分发</li></ol><p>如何找到需要分发的组件：</p><ol><li>获取依赖关系，可以通过遍历 <code>bundle</code>（<code>generateBundle</code> 钩子中）实现</li><li>获取全局组件、主包、分包信息，可以通过读取 <code>bundle[&#39;app.json&#39;]</code> 实现</li><li>根据依赖关系、分包列表等，分析数据，拿到需要分发的组件，以及要分发到哪里</li></ol><p>如何分析数据：</p><ol><li>依赖关系指的是“子子组件A =&gt; 子组件B =&gt; 页面C”这种关系</li><li>需要递归分析吗？必须需要。如果不递归，只能拿到第一层或者前几层的引用关系，无法得到使用一个组件的所有分包</li><li>分析时，首先能拿到的是“父引用子”，需要先递归，然后翻转，翻转就是让“子节点当作键”（理论上先翻转后递归也可以）</li><li><strong>递归分析，只要没被主包页面引用，就是被分包使用了</strong>。前提是组件是被使用的。就是从子节点到根结点，根结点一定属于某个分包或主包的一个页面。</li></ol><p>列一下符合规范的引用关系类型：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_ead9bded755b147684.png" width="500"><ol><li>主包组件 =&gt; 主包页面（直接引用）</li><li>主包组件 =&gt; ...主包组件... =&gt; 主包页面（间接引用）</li><li>主包组件 =&gt; 分包页面（直接引用）</li><li>主包组件 =&gt; ...主包组件.... =&gt; 分包页面（间接引用）</li><li>主包组件 =&gt; ...分包组件... =&gt; 分包页面（间接引用）</li><li>主包组件 =&gt; ...主包组件... =&gt; ...分包组件... =&gt; 分包页面（间接引用）</li><li>分包组件 =&gt; 分包页面（直接引用）</li><li>分包组件 =&gt; ...分包组件... =&gt; 分包页面（间接引用）</li></ol><p>其中类型 3、4、5、6 都是需要分发的。</p><p>分发步骤：</p><ol><li>移动组件到目标位置</li><li>修改引用关系</li><li>删除原有组件</li></ol><p>修改引用关系又分为：</p><ol><li>修改之前引用者的引用关系，比如“子组件=&gt;分包页面”中的分包页面</li><li>修改移动组件内部的引用关系，比如“子组件=&gt;分包页面”中的子组件</li></ol><p>第1步是精确替换，只替换对移动的组件的引用关系。第2步是全量替换，对所有引用关系进行替换。</p><p>第1步中，对于&quot;主包组件A =&gt; 主包组件B =&gt; 分包页面C&quot;这种关系，A被移动了，需要替换B中的引用关系吗？</p><p>其实是不需要的（第1步），如果A被移动了，说明B一定也被移动了，否则就会反向依赖，而这在数据分析阶段就已经规避了。</p><p><strong>主包组件B既属于1，又属于2，也就是既是被移动的组件，又是其他移动组件的父组件</strong>。需要在第一步排除（不处理），并在第二步的时候额外判断，取&quot;子子组件&quot;移动后真正的路径。</p><p>全局组件的最佳处理方式：</p><ol><li>把全局组件放到主包页面下的引用表中</li><li>后面分析的时候，自然会把全局组件排除</li><li>递归分析的时候，会把依赖全局组件的组件排除</li></ol><h2 id="_3-核心点" tabindex="-1">3. 核心点 <a class="header-anchor" href="#_3-核心点" aria-label="Permalink to &quot;3. 核心点&quot;">​</a></h2><p>几个核心点：</p><ol><li>递归分析引用关系，以及避免循环引用</li><li>找到需要派发的组件，以及目标位置</li><li>替换引用时，需要对移动组件内部的引用关系进行替换。这里用了正则去匹配，然后根据之前的组件位置、新的组件位置、之前的引用路径，生成新的引用路径。</li></ol><h2 id="_4-效果" tabindex="-1">4. 效果 <a class="header-anchor" href="#_4-效果" aria-label="Permalink to &quot;4. 效果&quot;">​</a></h2><p>在一个项目中使用了，并且配置了只有一个分包使用时才移动，主包能够减少 <code>0.8MB</code>，降低了 <code>41.5%</code>，并且由于只移动了最需要移动的，所以总包大小基本没有变化（变化的10K左右是由于生成的路径变深）。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_1ed8d8332bb4701483.png" width="550"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_986f687f40a5e5088d.png" width="550"><p>如果把 <code>limit</code> 设置为<code>0</code>，也就是只要主包不使用，就移动到分包中，可以将主包减少到 <code>1015KB</code>，降低了 <code>47%</code>。但由于多个分包中存在重复组件，总包也会增加。</p><p>使用方可以根据自身项目需要，灵活设置此选项。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_b7ea304f549baf1e73.png" width="550">',37)]))}const u=e(a,[["render",c]]);export{g as __pageData,u as default};
