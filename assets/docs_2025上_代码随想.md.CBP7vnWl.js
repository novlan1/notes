import{_ as e,c as t,o as r,ag as p}from"./chunks/framework.6d7lLjym.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2025上/代码随想.md","filePath":"docs/2025上/代码随想.md","lastUpdated":1749053051000}'),a={name:"docs/2025上/代码随想.md"};function s(n,o,i,d,l,c){return r(),t("div",null,o[0]||(o[0]=[p('<h2 id="_1-代码" tabindex="-1">1. 代码 <a class="header-anchor" href="#_1-代码" aria-label="Permalink to &quot;1. 代码&quot;">​</a></h2><p>项目管理是把代码当黑盒，技术是把代码当白盒。不要光从项目管理入手，更要从技术上入手。不要“<strong>技术不行就只会从项目管理上下手</strong>”。</p><p>归根到底，<strong>产品的表现是由代码决定的。每一个奇葩问题最终都可以定位到某一行或多行代码。要对每一行代码造成的影响了然于胸。</strong></p><p>刨根问底，<strong>要特别熟悉用到的框架的原理，掌握运行机制，遇到问题才不会慌。</strong></p><p>掌握原理，才知道为什么这么做，为什么不那么做，有没有更好的方式，有没有副作用，会不会对其他页面、其他地方产品影响。能说服自己，才可能是真的懂了。</p><p>有些问题其实是技术视野问题。</p><h2 id="_2-组件" tabindex="-1">2. 组件 <a class="header-anchor" href="#_2-组件" aria-label="Permalink to &quot;2. 组件&quot;">​</a></h2><p>组件是可以安全清空的，只要别删除，不会引起编译问题。而脚本不能清空，因为可能有地方引入它导出的变量。</p><p><strong><code>computed</code> 中写很长的逻辑一定是有问题的，一定是可以优化的。可以提取到单独的<code>ts</code>文件，并且不依赖<code>this</code>或组件变量，不与组件耦合</strong>。</p><p><strong>一个函数如果很长很长，一定是有问题的，一定可以优化。如果内部又有重复逻辑，那就是错上加错</strong>。一个vue文件很长很长未必就是错的。</p><h2 id="_3-产品" tabindex="-1">3. 产品 <a class="header-anchor" href="#_3-产品" aria-label="Permalink to &quot;3. 产品&quot;">​</a></h2><p><strong>要反复体验自己做的产品，并不断优化</strong>。</p><p>为什么呢？<strong>一个技术人本质上还是靠项目来成就，不管是技术上的成长，还是非技术的。而项目最终还是以产品的形式呈现，多么花里胡哨、变幻莫测、纷繁复杂的技术，最终也是表现为一个产品。帮助产品进步就是帮助自己</strong>。</p><p>结果说明一切，好的产品背后一定有好的技术，或者好的细节。</p><h2 id="_4-简单" tabindex="-1">4. 简单 <a class="header-anchor" href="#_4-简单" aria-label="Permalink to &quot;4. 简单&quot;">​</a></h2><p>大道至简。<strong>如果一种方式会代替另一种方式，那么新的方式一定比旧的方式简单。也就是复杂的实现一定会被废弃</strong>。</p><ul><li><p>扫码是非常简单的，碰一碰并没有比它简单多少，所以扫码并不会被取缔。</p></li><li><p>跨端技术一定会更加火热，因为它简单，只用写一份代码。低代码一定会持续低迷，因为它的原理比它的产物要复杂的多，它的成本比它的收益高得多。</p></li><li><p>多个小包是简单的，没有太多的耦合关系，所以 <code>Plugin Light</code> 升级成多包是正确的。</p></li><li><p><code>Press UI</code> 是简单的，没有打包，多种环境下运行的是同一份代码，方便调试。</p></li><li><p>条件编译是简单的，两行注释就能解决跨平台问题，还不会增大包体积，是伟大发明。</p></li><li><p><code>T Comm</code> 是简单的，提供工具方法，没有过多依赖，支持从子目录中引入，而且这个目录一旦被使用就绝不会被修改或删除，对使用者是简单的、没有心里负担的，从不担心 <code>breaking</code> 的问题。</p></li><li><p><code>Press</code> 系列组件库也从不会 <code>breaking</code>，对使用者是简单的。</p></li><li><p><code>Vue3</code> 是简单的，没有啥心智负担。</p></li><li><p><strong>通用的解决方案是简单的，所以一个团队最好用统一的技术栈，统一的模板，统一的底层工具</strong>。</p></li><li><p>找一个懂事的对象，生活是简单的，对比一个刁蛮的、作的、虚荣心强的，高下立判。</p></li><li><p>“卷”这个字就很简单，想想这个字没那么火之前，我们是怎么形容的，“工作压力大、竞争压力大、累...”</p></li></ul><h2 id="_5-经验" tabindex="-1">5. 经验 <a class="header-anchor" href="#_5-经验" aria-label="Permalink to &quot;5. 经验&quot;">​</a></h2><p>经验是什么？经验丰富指的是什么？</p><p><strong>解决过类似问题，处理过类似需求，有过差不多的经历。下次再做才会又快又好</strong>。从这个角度看，遇到困难是好事，是解决后可以提升自己的经验值。啥困难都没有，那可不是平平无奇嘛。</p><p>遇到问题，刨根问底，解决问题。</p><p>不光是自己遇到的，同事遇到的，你能帮他定位并解决了，不是也提升你的经验了吗？</p><p><strong>经验内在含义是，有自己的感悟，有独特的理解，有深入的思考。没有经历过，肯定是不可能有深入思考和自己感悟的。但是经历过，也不意味着就一定有深入思考</strong>。</p><h2 id="_6-其他" tabindex="-1">6. 其他 <a class="header-anchor" href="#_6-其他" aria-label="Permalink to &quot;6. 其他&quot;">​</a></h2><p><strong>预发布验证对后台能力有要求，不能是<code>breaking</code>的</strong>，不能对现有字段含义做变更，否则后端发布了，前端没发布，会产生<code>bug</code>。</p><p>如何更好的时间管理？<strong>列TODO，明确且可执行的事项</strong>。</p><p>倾向于晚上加班，而不是周末加班。<strong>一鼓作气，减少上下文切换</strong>。</p><p><strong>还是做技术好，只要自己设计的好，写的好，不用改来改去</strong>。不用担心被人抢功，被别人拿去汇报。</p><p><strong>任何在线上跑的项目，不论多古老，几乎百分之百都会再改的</strong>。技术栈可能会迁移、变更、淘汰，但代码规范、代码风格是可以延续的。如果你的每个组件、函数、类都短小精悍，后来人会感激你的。如果你的工具库、组件库始终向后兼容，后来人也是会感激你的。</p><p><strong>制定目标，最重要的一点是，跳一跳，够得着</strong>。</p><p><strong>重视每个小优化，是积少成多，是量变产生质变的开始</strong>，更重要的是把他们分类，把点串成线，思考它们的本质，以及如何快速移植到其他项目。</p><p>互联网流动性强是不是跟埋雷、挖坑、技术债太高有关，挖了很大的坑，但是拍拍屁股就走了。</p><p>把这个项目称为屎山，我认为是侮辱屎。</p><p><strong>口碑就是超出预期</strong>。互联网特征：专注、极致、口碑、快（来自雷军）。</p><p>关键点，重要点，本质上。原则。</p>',35)]))}const h=e(a,[["render",s]]);export{_ as __pageData,h as default};
