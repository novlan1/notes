import{_ as o,c as r,o as c,a2 as d}from"./chunks/framework.CriqKoQt.js";const h=JSON.parse('{"title":"之前的笔记","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2025下/notes-before.md","filePath":"docs/2025下/notes-before.md","lastUpdated":1769936003000}'),t={name:"docs/2025下/notes-before.md"};function p(a,e,s,b,n,l){return c(),r("div",null,e[0]||(e[0]=[d('<h1 id="之前的笔记" tabindex="-1">之前的笔记 <a class="header-anchor" href="#之前的笔记" aria-label="Permalink to &quot;之前的笔记&quot;">​</a></h1><p>张一鸣：<strong>有时候大家的认知和事实会差很远很远，比如，2012年的时候没人看好移动互联网。</strong></p><p>代码不会背叛你，运动、肌肉也不会背叛你，但是打游戏会。你越强，却给你匹配更强的对手和更菜的队友，感觉像是遭到了背叛。</p><p><strong>简单不等于容易，把复杂的东西做简单，不代表它就容易</strong>。</p><p>会沉淀、封装就能超过80%的前端开发者了。</p><br><br><hr><br><br><p><strong>只有质量好，才能走得快</strong>。</p><p>对于研发团队来说，做债务治理要投入人力，一定会和产品经理做需求的欲望有冲突。但只有质量好才能走得快，产研的目标是一致的，这是技术管理者的职责，需要和产品经理沟通对齐好。</p><br><br><hr><br><br><p>对框架理解越深，解决问题的速度越快，熟悉原理的人可能一分钟就解决了，不熟悉的可能需要一星期。</p><br><br><hr><br><br><p><code>cardInfo</code>、<code>cardCustom</code> 的获取只能从card组件中获取，不能提升到子活动详情中，因为“我的”页面也要用这个组件，如果提升，两个都要提升，逻辑重复。</p><p>可以通过 <code>ebus</code>，监听 <code>cardInfo</code>、<code>cardCustom</code> 的变化，一旦变化，就广播出去，子活动详情中，记录它们的值，并根据数据对 <code>button</code> 做展示。</p><br><br><hr><br><br><p>乘以 <code>0.25</code> 就是除以 <code>4</code>，看到 <code>pr-1.28</code> 就想到 <code>1.28*0.25</code>，即 <code>1.28 / 4 = 0.32rem</code></p><br><br><hr><br><br><p>状态码可以复用，对原始数据进行解析，得到的状态码一定是唯一的。如果横竖版一定要分开，可以在横版的组件中单独加判断，即组合判断。</p><p>状态码的复用，可以减少大量重复逻辑。</p><br><br><hr><br><br><p>(pixui?) 没有 <code>localStorage</code>，没有 <code>globalThis</code>，没有 <code>Array.prototype.includes</code>（<code>aegis</code> 中有用），没有 <code>Array.prototype.flatMap</code></p><p><code>globalThis</code> 的 <code>polyfill</code> 和其他变量不一样，它自己本身是顶级变量，每个上下文都需要单独 <code>polyfill</code>，更好的做法是不用它。</p><br><br><hr><br><br><p><code>calendar</code> 支持 <code>switchMode</code>，就是可以在头部快速切换年月。</p><p>这个功能要维护一个 <code>currentMonth</code>，数组，理论上只有一项。之前下面遍历的是 <code>months</code>，现在要判断 <code>switchMode</code>，不为 <code>none</code> 时，要遍历 <code>currentMonth</code>。</p><br><br><hr><br><br><p>slider 点击时获取detla的核心逻辑，e.clienX - line.left，e的类型是 MouseEvent | Touch</p><p>range类型时，点击line，需要判断当前移动的是左边还是右边，判断公式为 点击处与两点距离的绝对值，哪个小，就说明哪个近，就移动哪个。 distanceLeft = Math.abs(e.clientX - leftDot.left); distanceRight = Math.abs(rightDot.left - e.clientX);</p><br><br><hr><br><br><p>nvm 指定默认的node版本</p><p><code>nvm alias default &lt;version&gt;</code> 如： <code>nvm alias default 20</code></p><br><br><hr><br><br><p>Hooks 只能在函数组件的顶级作用域使用。</p><p>所谓顶层作用域，就是 Hooks 不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层。同时 Hooks 在组件的多次渲染之间，必须按顺序被执行。因为在 React 组件内部，其实是维护了一个对应组件的固定 Hooks 执行列表的，以便在多次渲染之间保持 Hooks 的状态，并做对比。</p><p>所以 Hooks 的这个规则可以总结为两点：第一，所有 Hook 必须要被执行到。第二，必须按顺序执行。</p><br><br><hr><br><br>- <p>在 React 函数组件中，每一次 UI 的变化，都是通过重新执行整个函数来完成的，这和传统的 Class 组件有很大区别：函数组件中并没有一个直接的方式在多次渲染之间维持一个状态。</p><br><br><hr><br><br>- ',87)]))}const f=o(t,[["render",p]]);export{h as __pageData,f as default};
