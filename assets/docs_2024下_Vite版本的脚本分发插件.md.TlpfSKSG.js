import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.6d7lLjym.js";const r=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2024下/Vite版本的脚本分发插件.md","filePath":"docs/2024下/Vite版本的脚本分发插件.md","lastUpdated":1746462147000}'),l={name:"docs/2024下/Vite版本的脚本分发插件.md"};function t(h,s,o,p,d,c){return e(),a("div",null,s[0]||(s[0]=[n(`<h2 id="_1-开始" tabindex="-1">1. 开始 <a class="header-anchor" href="#_1-开始" aria-label="Permalink to &quot;1. 开始&quot;">​</a></h2><p>遇到一个比较大的项目从 <code>Vue2</code> 的 <code>uni-app</code> 迁移到 <code>Vue3</code>，主包大小又超了，在组件分发的基础上，做了脚本分发，这里简单记录下。</p><p>脚本分发就是把只有分包使用的<code>js/ts</code>等放到对应的分包，而不是基于目录位置。</p><h2 id="_2-实现" tabindex="-1">2. 实现 <a class="header-anchor" href="#_2-实现" aria-label="Permalink to &quot;2. 实现&quot;">​</a></h2><h3 id="_2-1-默认打包策略" tabindex="-1">2.1. 默认打包策略 <a class="header-anchor" href="#_2-1-默认打包策略" aria-label="Permalink to &quot;2.1. 默认打包策略&quot;">​</a></h3><p><code>uni-app</code> <code>Vue3</code> 版本默认打包策略如下:</p><ol><li><code>assets</code> 文件，比如 <code>png/pdf/ttf</code> 等文件，放到 <code>common/assets</code></li><li>项目内 <code>js/ts</code>，但不是 <code>page/component</code> 对应的文件，<strong>放到相对目录位置</strong></li><li>项目外 <code>js/ts</code> 放到 <code>common/vendor</code></li><li><code>isVueJs</code> 文件，放到 <code>common/vendor</code></li><li><code>node_modules</code> 下非 <code>js/ts/css</code> 文件，并且是入口文件（<code>getModuleInfo(id).isEntry</code> 为 <code>true</code>），放到 <code>common/vendor</code></li></ol><p>源码位置：<code>packages/uni-mp-vite/src/plugin/build.ts</code>。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createMoveToVendorChunkFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GetManualChunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inputDir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> normalizePath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UNI_INPUT_DIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">getModuleInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> normalizedId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> normalizePath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> normalizedId.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">split</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;?&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理资源文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEFAULT_ASSETS_RE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;common/assets&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理项目内的js,ts文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EXTNAME_JS_RE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (filename.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startsWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inputDir) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">filename.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">includes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node_modules&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> chunkFileName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeExt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          normalizePath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">relative</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inputDir, filename))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chunkFileNameBlackList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">includes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(chunkFileName) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasJsonFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(chunkFileName) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 无同名的page,component</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chunkFileName</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 非项目内的 js 资源，均打包到 vendor</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;common/vendor&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      isVueJs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(normalizedId) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      (normalizedId.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">includes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node_modules&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isCSSRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(normalizedId) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 使用原始路径，格式化的可能找不到模块信息 https://github.com/dcloudio/uni-app/issues/3425</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        staticImportedByEntry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id, getModuleInfo, cache))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;common/vendor&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>相比于 <code>Vue2</code> 版本，有几个不同：</p><ol><li>基于目录位置进行打包</li><li>不存在分包的 <code>common/vendor</code></li><li>公共目录下的文件，即使只有1个子包使用，也是放到主包中，即 <code>common/vendor</code></li></ol><p><code>Vue2</code> 版本的<a href="https://zh.uniapp.dcloud.io/collocation/manifest.html#%E5%85%B3%E4%BA%8E%E5%88%86%E5%8C%85%E4%BC%98%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E" target="_blank" rel="noreferrer">分包优化</a>说明。</p><h3 id="_2-2-项目遗留问题" tabindex="-1">2.2. 项目遗留问题 <a class="header-anchor" href="#_2-2-项目遗留问题" aria-label="Permalink to &quot;2.2. 项目遗留问题&quot;">​</a></h3><p>调试发现上面代码里的 <code>process.env.UNI_INPUT_DIR</code> 也就是 <code>inputDir</code> ，在我们项目中是相对路径，比如 <code>src/project/user</code>，而插件内的 <code>filename</code> 是绝对路径，导致 <code>filename.startsWith(inputDir)</code> 一定为 <code>false</code>，从而让所有文件都放到 <code>common-vendor</code> 中。</p><p>而 <code>uni-app</code> 官方 <code>demo</code> 中 <code>process.env.UNI_INPUT_DIR</code> 其实是绝对路径，我们项目是 <code>monorepo</code>，所以是覆盖了这个变量。</p><p>另外，项目中有大量依赖混乱的问题：</p><ul><li>主包引用子包</li><li>子包引用其他子包</li></ul><p>如果强行改成绝对路径，会导致引用错误。比如 <code>src/project/user/views/sche/logic/reset-sche.js</code>，按照上面的规则，是打包到 <code>views/sche/logic/reset-sche.js</code> 位置。但是它又被主包的JS引用，形成了循坏依赖。</p><ol><li>主包JS打包成 <code>common/vendor</code>，依赖 <code>views/sche/logic/reset-sche.js</code></li><li><code>views/sche/logic/reset-sche.js</code> 打包成 <code>views/sche/logic/reset-sche.js</code>，引用主包内其他JS，即依赖 <code>common/vendor</code></li></ol><p>报错信息：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_d0f6532827b3cd18db.png" width="500"><p>common/vendor 相关内容：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_c02d488b4f5347989d.png" width="500"><p><code>views/sche/logic/reset-sche.js</code> 相关内容：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_a9299e602389d6fbb3.png" width="500"><h3 id="_2-3-最佳出路" tabindex="-1">2.3. 最佳出路 <a class="header-anchor" href="#_2-3-最佳出路" aria-label="Permalink to &quot;2.3. 最佳出路&quot;">​</a></h3><p><strong>修改 <code>process.env.UNI_INPUT_DIR</code> 为绝对路径，并梳理项目代码，杜绝错误依赖问题，是减包的最佳出路</strong>。</p><p>但今天不介绍这个，介绍的是脚本分发。我们想下，即使我们的依赖梳理很清楚了，一些模块依然不得不放到公共路径，比如它可能是第三方依赖，<code>node_modules</code>下的内容。如何将它打到分包中呢？</p><h3 id="_2-4-脚本分发" tabindex="-1">2.4. 脚本分发 <a class="header-anchor" href="#_2-4-脚本分发" aria-label="Permalink to &quot;2.4. 脚本分发&quot;">​</a></h3><p>脚本分发插件主要工作都在 <code>build.rollupOptions.output.manualChunks</code> 配置中进行。</p><ol><li>根据 <code>id/getModuleInfo</code> 等获取依赖关系</li><li>判断最终使用者只有一个分包，就打到分包中</li></ol><p>如何获取依赖关系：</p><ol><li>涉及两个核心概念，<code>importers</code> 和 <code>dynamicImporters</code>，前者是引用者，后者是动态引用者</li><li>小程序中并没有真正的动态引用，可以认为是 <code>uni-app</code> 巧妙了利用这个字段记录了组件的依赖关系</li><li><code>getModuleInfo</code> 会返回 <code>importers</code> 和 <code>dynamicImporters</code>，向上递归就能获取到完整的依赖关系</li></ol><p>与组件分发中收集依赖的差别：</p><ol><li>组件分发中能拿到整个<code>bundle</code>，脚本分发中只能拿到自己以及父节点</li><li>可以认为<strong>组件分发能拿到整棵树，脚本分发只能拿到一个树枝</strong></li></ol><p><code>uni-app</code> 对组件有特殊处理：</p><ol><li>特殊处理指的是将组件在<code>load</code>和<code>transform</code>时进行了<strong>虚拟化</strong></li><li>推测是为了简化打包处理，比如不用考虑打到<code>vendor</code>，断开与JS的引用关系。</li><li><strong>虚拟组件以 <code>uniComponent://</code> 开头，虚拟页面以 <code>uniPage://</code> 开头，并都进行了 <code>base64</code> 编码</strong></li><li>用 <code>base64</code> 编码的好处是，可以无损解码</li></ol><p><code>uni-app</code> 中组件的引用关系：</p><ol><li><code>importers</code> 关系: JS =&gt; [组件A, 其他] =&gt; [虚拟组件A]</li><li><strong><code>dynamicImporters</code> 关系: 虚拟组件A =&gt; [组件B, 其他]</strong></li><li><strong><code>importers</code> 关系: 组件B =&gt; [虚拟组件B]</strong></li><li><code>dynamicImporters</code> 关系: 虚拟组件B =&gt; [组件C, 其他]</li><li><code>importers</code> 关系: ...</li></ol><p>从上面可以看到，涉及到组件的，就会转为虚拟组件，<strong>要找组件的引用关系，就是找对应虚拟组件的 <code>dynamicImporters</code></strong>。</p><p>递归寻找引用者时需要注意：</p><ol><li>缓存节点，避免重复寻找</li><li>注意循环引用，<strong>遇到循环引用的一律当成主包内容</strong>，不处理，避免出错</li></ol><p>基本上找到这个树枝，就完成大部分工作了，剩下的是寻找分包：</p><ol><li>被 <code>main.ts/App.vue</code> 使用了，返回主包</li><li>被主包页面使用了，返回主包</li><li>被分包页面使用了，返回分包</li><li><strong>被分包组件使用了，也返回分包</strong></li></ol><p>全部分析完后，就能筛选出哪些需要分发了，返回一个合成的子包路径即可。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> targetName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subPackages</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}/\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dispatchDir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}/\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dispatchChunkFileName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="_3-效果" tabindex="-1">3. 效果 <a class="header-anchor" href="#_3-效果" aria-label="Permalink to &quot;3. 效果&quot;">​</a></h2><p>使用后能减少 <code>130KB</code>。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_649de2fcc66b512bb3.png" width="500"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_c0afad5ba87391b28d.png" width="500"><h2 id="_4-感悟" tabindex="-1">4. 感悟 <a class="header-anchor" href="#_4-感悟" aria-label="Permalink to &quot;4. 感悟&quot;">​</a></h2><blockquote><p>你如果深刻理解它，你就会把代码写的又简单、又直接、又没有bug、性能又好，你如果不理解它，你就会把代码写的又臭又长，bug又多，又难维护、难理解。</p><p>有时候，越快完成，写得越好，越慢完成，写得越差</p></blockquote><h2 id="_5-参考" tabindex="-1">5. 参考 <a class="header-anchor" href="#_5-参考" aria-label="Permalink to &quot;5. 参考&quot;">​</a></h2><ol><li><a href="https://juejin.cn/post/7135671174893142030" target="_blank" rel="noreferrer">https://juejin.cn/post/7135671174893142030</a></li><li><a href="https://github.com/sanyuan0704/vite-plugin-chunk-split/blob/master/README-CN.md" target="_blank" rel="noreferrer">https://github.com/sanyuan0704/vite-plugin-chunk-split/blob/master/README-CN.md</a></li></ol><hr><p>分割线，后面聊聊依赖关系</p><hr><h2 id="_6-依赖关系" tabindex="-1">6. 依赖关系 <a class="header-anchor" href="#_6-依赖关系" aria-label="Permalink to &quot;6. 依赖关系&quot;">​</a></h2><p>有几种引用错误</p><ol><li>主包引用子包</li><li>子包引用其他子包</li><li>循环依赖</li><li>JS/TS 引用 Vue 文件（小程序下）</li></ol><p>脚本分发插件可以分析依赖，能输出前三种错误信息，帮助开发者快速定位问题 。</p><hr><p>分割线，后面聊聊 uni-app 的路由</p><hr><h2 id="_7-路由" tabindex="-1">7. 路由 <a class="header-anchor" href="#_7-路由" aria-label="Permalink to &quot;7. 路由&quot;">​</a></h2><h3 id="_7-1-uni-app-中的路由" tabindex="-1">7.1. uni-app 中的路由 <a class="header-anchor" href="#_7-1-uni-app-中的路由" aria-label="Permalink to &quot;7.1. uni-app 中的路由&quot;">​</a></h3><h4 id="_7-1-1-h5-vue3" tabindex="-1">7.1.1. H5（Vue3） <a class="header-anchor" href="#_7-1-1-h5-vue3" aria-label="Permalink to &quot;7.1.1. H5（Vue3）&quot;">​</a></h4><ol><li><code>uni-app</code> 内部也是用的 <code>vue-router</code>，能找到 <code>createRouter</code> API的调用</li><li><code>createRouter</code> 中 <code>routes</code> 参数使用的是 <code>__uniRoutes</code>，这是 <code>uni-app</code> 内部变量，有 <code>path/alias/meta/loader/component</code> 几个属性。直接在控制台打印 <code>window.__uniRoutes</code> 就能看到</li><li><code>createRouter</code> 源码路径：<code>packages/uni-h5-vite/src/plugins/pagesJson.ts</code>，或搜索 <code>generatePagesRoute</code></li><li><code>__uniRoutes</code> 都没有 <code>name</code> 属性，自然无法通过 <code>name</code> 跳转，即 <code>$router.push({ name: &#39;xxx&#39; })</code> 不可行，只能通过 <code>path</code> 跳转</li></ol><h4 id="_7-1-2-h5-vue2" tabindex="-1">7.1.2. H5（Vue2） <a class="header-anchor" href="#_7-1-2-h5-vue2" aria-label="Permalink to &quot;7.1.2. H5（Vue2）&quot;">​</a></h4><ol><li>同样用的 <code>vue-router</code></li><li>Vue2 中 <code>__uniRoutes</code> 的生成逻辑源码在：<code>packages/webpack-uni-pages-loader/lib/platforms/h5.js</code>，或搜索 <code>genPageRoutes</code></li></ol><h4 id="_7-1-3-非-h5" tabindex="-1">7.1.3. 非 H5 <a class="header-anchor" href="#_7-1-3-非-h5" aria-label="Permalink to &quot;7.1.3. 非 H5&quot;">​</a></h4><p><code>uni-app</code> 在非H5端没有提供 <code>$router</code>，推荐直接使用 <code>uni.navigateTo</code> 等原生语法。</p><h3 id="_7-2-h5中路由的多样性" tabindex="-1">7.2. H5中路由的多样性 <a class="header-anchor" href="#_7-2-h5中路由的多样性" aria-label="Permalink to &quot;7.2. H5中路由的多样性&quot;">​</a></h3><p>路由有3种形式</p><ol><li>动态路由，比如 <code>/match/match-detail/52973147</code></li><li><code>aliasPath + query</code>，<code>aliasPath</code> 就是路径别名，比如 <code>/match-list?siteId=2066002</code></li><li><code>fullPath + query</code>，<code>fullPath</code> 就是全部路径，比如 <code>views/match-list/match-list?siteId=2066002</code></li></ol><p>非 <code>uni-app</code> 项目我更倾向于用1，参数精炼。<code>uni-app</code> 项目我更倾向于用3，好处有：</p><ol><li>多端统一，无需额外兼容、转化</li><li>所见即所得，无心智负担</li></ol><p>路由有两种模式，<code>hash</code> 和 <code>history</code>，结合上面提到的3种形式，总共有 <code>2 * 3 = 6</code> 种类型。</p><h3 id="_7-3-命名路由" tabindex="-1">7.3. 命名路由 <a class="header-anchor" href="#_7-3-命名路由" aria-label="Permalink to &quot;7.3. 命名路由&quot;">​</a></h3><p>毫无疑问，命名路由有<a href="https://router.vuejs.org/zh/guide/essentials/named-routes.html" target="_blank" rel="noreferrer">很多好处</a>，比如没有硬编码，不会担心打错 <code>path</code>。</p><p>但是考虑到统一性，新项目还是建议直接用 <code>path</code>。</p><h3 id="_7-4-重定向" tabindex="-1">7.4. 重定向 <a class="header-anchor" href="#_7-4-重定向" aria-label="Permalink to &quot;7.4. 重定向&quot;">​</a></h3><p>非跨端转跨端，以及 vue2 升级 vue3，都会遇到映射路由表的问题。当前实现了：</p><ol><li><code>hash + dynamic</code> =&gt; <code>history + aliasPath query</code>，如 <code>/#/match-detail/123 =&gt; /match-detail?childId=123</code></li><li><code>history + aliasPath query</code> =&gt; <code>history + fullPath query</code>，如 <code>/match-detail?childId=123 =&gt; /match/match-detail?childId=123</code></li></ol><p>其他几种类似。</p><h3 id="_7-5-动态路由" tabindex="-1">7.5. 动态路由 <a class="header-anchor" href="#_7-5-动态路由" aria-label="Permalink to &quot;7.5. 动态路由&quot;">​</a></h3><p>是 <code>uni-simple-router</code> 支持的动态路由，<code>uni-app</code>框架本身不支持，具体是在初始化的时候，在 <code>routes</code> 中定义了 <code>aliasPath</code>。</p><p>uni-app 使用 <code>vue-router</code> 时，传入的还是 <code>path</code>，即页面路径，这种无法支持动态路由。这一点可以通过打印 <code>window.__uniRoutes</code> 看出。引入 <code>uni-simple-router</code> 后，再打印 <code>window.__uniRoutes</code>，会发现 <code>path</code> 变成了动态路由，比如 <code>/match/match-detail/:childid</code>，这是 <code>uni-simple-router</code> 中 <code>src/H5/buildRouter.ts</code> 做的，将 <code>aliasPath</code> 赋值给了 <code>path</code>。</p>`,88)]))}const E=i(l,[["render",t]]);export{r as __pageData,E as default};
