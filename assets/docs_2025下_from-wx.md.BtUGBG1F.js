import{_ as i,c as e,o as a,a2 as o}from"./chunks/framework.CriqKoQt.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2025下/from-wx.md","filePath":"docs/2025下/from-wx.md","lastUpdated":1771340776000}'),l={name:"docs/2025下/from-wx.md"};function n(t,s,p,d,h,c){return a(),e("div",null,s[0]||(s[0]=[o(`<h2 id="_1-笔记" tabindex="-1">1. 笔记 <a class="header-anchor" href="#_1-笔记" aria-label="Permalink to &quot;1. 笔记&quot;">​</a></h2><ul><li>可移植性好，比如 <code>markdown</code> 这种统一的格式</li><li>有历史记录，删除后可找回，比如放 <code>git</code> 上管理</li></ul><h2 id="_2-csrf" tabindex="-1">2. CSRF <a class="header-anchor" href="#_2-csrf" aria-label="Permalink to &quot;2. CSRF&quot;">​</a></h2><h3 id="_2-1-cookie主要的一些特性" tabindex="-1">2.1. Cookie主要的一些特性 <a class="header-anchor" href="#_2-1-cookie主要的一些特性" aria-label="Permalink to &quot;2.1. Cookie主要的一些特性&quot;">​</a></h3><ol><li>发送HTTP请求时，浏览器默认自动携带本次请求域名的 <code>Cookie</code>（不管是通过什么方式，在什么页面发送的HTTP请求）</li><li>读写 <code>Cookie</code> 有跨域限制(作用域，<code>Domain</code>，<code>Path</code>)</li><li>生命周期(会话or持久)</li></ol><h3 id="_2-2-csrf的攻击过程" tabindex="-1">2.2. CSRF的攻击过程 <a class="header-anchor" href="#_2-2-csrf的攻击过程" aria-label="Permalink to &quot;2.2. CSRF的攻击过程&quot;">​</a></h3><p>登录态 Cookie 的 Key 是浏览器默认自动携带的，Key 通常是会话 Cookie，只要浏览器不关闭，Key 一直存在。</p><p>所以只要用户A曾经登录过相册网站(这里用 <code>www.photo.com</code> 举例)，浏览器没有关闭，用户在没有关闭的浏览器打开一个黑客网页(这里用 <code>www.hacker.com</code>)，黑客页面发送HTTP请求到 <code>www.photo.com</code> 的后台会默认带上 <code>www.photo.com</code> 的登录态 Cookie，也就能模拟用户A做一些增删改等敏感操作。Get 和 Post 都一样，这就是CSRF攻击原理。</p><h3 id="_2-3-读操作能否被攻击到" tabindex="-1">2.3. 读操作能否被攻击到？ <a class="header-anchor" href="#_2-3-读操作能否被攻击到" aria-label="Permalink to &quot;2.3. 读操作能否被攻击到？&quot;">​</a></h3><p>上面说的增删改都是写操作，会对后台数据产生负面影响，所以是能被攻击的。另外一种读操作，是具有幂等性，不会对后台数据产生负面影响，能否被攻击到？读操作也可能是敏感数据，举个例子，比如 <code>www.photo.com</code> 上的私密相册数据能否被 <code>www.hacker.com</code> 页面拿到？这就涉及到前端跨域知识点了，默认大部分情况是拿不到，这里列举两种特殊情是可以拿到的：</p><ul><li>如果后台返回的数据是 JSONP 格式的，这种只能是 Get 操作，是能被黑客页面拿到的。</li><li>如果后台是通过 CORS 处理跨域，没有对请求头的 Origin 做白名单限制，ACAO 响应头是<code>*</code>或者包括黑客页面，包括<code>Get/Post/Del</code>等操作，也是能被黑客页面拿到的。</li></ul><p>除了这两种特殊情况，读操作都是不能被攻击到的，因为浏览器跨域限制是天然的安全的。</p><h3 id="_2-4-token-方案防御-csrf" tabindex="-1">2.4. Token 方案防御 CSRF <a class="header-anchor" href="#_2-4-token-方案防御-csrf" aria-label="Permalink to &quot;2.4. Token 方案防御 CSRF&quot;">​</a></h3><p>上面讲到 Cookie 的一些特性的第二条，读写 Cookie 有跨域限制(作用域，Domain，Path)，所以我们可以用这个特性来区分是自己页面还是黑客页面。只要页面能读（或者写）<code>www.photo.com</code> 域名 Cookie，就证明是自己的页面。懂了原理，方案就很简单，比如服务器通过 <code>cookie</code> 下发一个 <code>token</code>，<code>token</code> 值是随机数，页面发请求的时候从 <code>cookie</code> 取出 <code>token</code> 通过HTTP请求参数传给后台，后台比对参数里的 <code>token</code> 和 <code>cookie</code> 里的 <code>token</code> 是否一致，如果一致就证明是自己页面发的请求，如果不一致就返回失败。防CSRF的方案就是这么简单，这种方法能够100%防CSRF。</p><h3 id="_2-5-token是前台生产还是后台生产" tabindex="-1">2.5. Token是前台生产还是后台生产？ <a class="header-anchor" href="#_2-5-token是前台生产还是后台生产" aria-label="Permalink to &quot;2.5. Token是前台生产还是后台生产？&quot;">​</a></h3><p>上面例子是后台生成传到前台的，大家发现其实后台并没有存这个 token，所以原理上前后台生成都可以，只要保证随机性。如果前端生成 token 然后写到 Cookie 里，然后HTTP请求参数也带上 token，后端逻辑一样比对参数里的token和cookie里的token是否一致，如果一致就证明是自己页面发的请求，如果不一致就返回失败。这就是Cookie读和写的差别，只要能读写自己域名的Cookie就是自己页面。</p><h3 id="_2-6-token放在http参数里的哪里" tabindex="-1">2.6. Token放在HTTP参数里的哪里？ <a class="header-anchor" href="#_2-6-token放在http参数里的哪里" aria-label="Permalink to &quot;2.6. Token放在HTTP参数里的哪里？&quot;">​</a></h3><p>放在URL的querystring里，Post请求的Data里或者HTTP请求头里，这三种方式都可以，只是有一点点细微的差别。如果querystring里，可能会影响Get请求的缓存效果，因为重新登录之后token会变，url也就变了，之前的缓存就失效了。如果放在HTTP请求头里，就需要使用fetch或者XHR发请求，这样会变成复杂请求，跨域情况需要多一次Option预检请求，对性能多少有一点点影响。</p><h3 id="_2-7-cookie的samesite属性可以么" tabindex="-1">2.7. Cookie的SameSite属性可以么？ <a class="header-anchor" href="#_2-7-cookie的samesite属性可以么" aria-label="Permalink to &quot;2.7. Cookie的SameSite属性可以么？&quot;">​</a></h3><p>不好用，SameSite设计的目的貌似就是防CSRF，但是我觉得不好用，SameSite有三个值Strict/Lax/None，设置的太严格，会影响自己业务的体验，设置的太松没有效果，就算最严格Strict模式，也防不了我上面提到写操作用Get请求，UGC页面有自定义照片的情况。并且还有小部分老浏览器不支持，最终其实还是Token方案好用。</p><h3 id="_2-8-cookie的httponly属性可以么" tabindex="-1">2.8. Cookie的HTTPOnly属性可以么？ <a class="header-anchor" href="#_2-8-cookie的httponly属性可以么" aria-label="Permalink to &quot;2.8. Cookie的HTTPOnly属性可以么？&quot;">​</a></h3><p>不行，HTTPOnly表示这个Cookie只能是HTTP请求可以读写，js没有读写权限，浏览器还是会默认带上，所以登录态校验是通过的。如果设置了HTTPOnly还有副作用，上面说的Token方案就用不了了。</p><h3 id="_2-9-验证码可以么" tabindex="-1">2.9. 验证码可以么？ <a class="header-anchor" href="#_2-9-验证码可以么" aria-label="Permalink to &quot;2.9. 验证码可以么？&quot;">​</a></h3><p>不行，验证码是用来防机器暴力攻击的，验证码是用来确认敏感操作是自然人发送还是机器自动发送。这里举个图片验证码的例子，大概原理是前端通过img标签展示图片验证码给用户看(图片字母经过噪音处理的)，这个图片HTTP请求也会设置一个cookie如codeID=xxx(加密的),用户在输入框输入图片中展示的字母，敏感操作的HTTP请求通过参数把用户输入的code传给后台，后台拿到用户输入的code和cookie里的codeID(通常需要通过id查数据库)做比较，如果一致就通过。这种验证码系统能够防机器攻击，但是防不了CSRF，黑客同样可以在黑客的页面展示验证码给用户，通过诱导用户输入验证码完成攻击操作，只能是提高了CSRF攻击成功的门槛，但是只要黑客页面诱导信息劲爆还是有很大部分用户会上当的。因为用户不知道输入验证码后会产生什么影响。</p><p>题外话，验证码我在一些资料上看到说可以用来防CSRF，我个人觉得是不行的，包括手机验证码都不行，详细情况大家可以研究各种验证码的实现原理。我猜到有人可能有不同意见，非要构造一种能防CSRF的验证码技术上也是可行的。</p><h2 id="_3-k8s" tabindex="-1">3. K8S <a class="header-anchor" href="#_3-k8s" aria-label="Permalink to &quot;3. K8S&quot;">​</a></h2><p>用户 =&gt; 请求 =&gt; ingress =&gt; service =&gt; pod</p><ol><li><code>deployment</code> 包含了整个k8s的部署信息，字段包括 <code>containers</code>，<code>image</code>，<code>imagePullSecrets</code></li><li><code>ingress</code> 字段包括 <code>existLbId（clb id）</code>，<code>tls.secretName</code></li><li><code>service</code> 字段包括 <code>ports</code>（又包括 <code>name</code>，<code>port</code>，<code>protocol</code>，<code>targetPort</code>，<code>nodePort</code>）</li></ol><h2 id="_4-node" tabindex="-1">4. Node <a class="header-anchor" href="#_4-node" aria-label="Permalink to &quot;4. Node&quot;">​</a></h2><p>Node ＞ Pod ＞ 容器</p><h2 id="_5-powerlevel10k" tabindex="-1">5. powerlevel10k <a class="header-anchor" href="#_5-powerlevel10k" aria-label="Permalink to &quot;5. powerlevel10k&quot;">​</a></h2><p>powerlevel10k 主题配置</p><p>自定义配置命令： <code>p10k configure</code></p><p>参考：<a href="https://www.haoyep.com/posts/zsh-config-oh-my-zsh/" target="_blank" rel="noreferrer">https://www.haoyep.com/posts/zsh-config-oh-my-zsh/</a></p><h2 id="_6-eslint-总是报错" tabindex="-1">6. Eslint 总是报错 <a class="header-anchor" href="#_6-eslint-总是报错" aria-label="Permalink to &quot;6. Eslint 总是报错&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TypeError: services.getTypeAtLocation is not a function</span></span></code></pre></div><p>查看源码，是 <code>typescript-eslint</code> 的包相关，但是包里已经有导出了。</p><p>解决：删除 <code>node_modules</code>，重新 <code>pnpm i</code>，猜测有 <code>eslint</code> 缓存。</p><h2 id="_7-gitconfig-配置" tabindex="-1">7. <code>~/.gitconfig</code> 配置 <a class="header-anchor" href="#_7-gitconfig-配置" aria-label="Permalink to &quot;7. \`~/.gitconfig\` 配置&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[user]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> novlan1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  email</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1576271227@qq.com</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[includeIf </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;gitdir:~/Documents/git-woa/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/.gitconfig-work</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[pull]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rebase</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[init]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  defaultBranch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> master</span></span></code></pre></div><h2 id="_8-vue3-中的-water" tabindex="-1">8. Vue3 中的 water <a class="header-anchor" href="#_8-vue3-中的-water" aria-label="Permalink to &quot;8. Vue3 中的 water&quot;">​</a></h2><p><code>vue3</code> 中使用 <code>water.foo(this)</code>，<code>foo</code> 中 <code>water = this</code>，这时 <code>water</code> 就不再是响应式了。</p><h2 id="_9-react-中-ontouchmove" tabindex="-1">9. React 中 onTouchMove <a class="header-anchor" href="#_9-react-中-ontouchmove" aria-label="Permalink to &quot;9. React 中 onTouchMove&quot;">​</a></h2><p>React 中 <code>onTouchMove</code> 事件无法 <code>preventDefault</code>，因为默认是 <code>passive</code>。</p><p>解决办法是不用 <code>onTouchMove</code>，而是创建一个 <code>ref</code>，监听 <code>ref.current</code> 的 <code>touchmove</code> 事件。</p><p>参考：<a href="https://stackoverflow.com/questions/63663025/react-onwheel-handler-cant-preventdefault-because-its-a-passive-event-listener" target="_blank" rel="noreferrer">https://stackoverflow.com/questions/63663025/react-onwheel-handler-cant-preventdefault-because-its-a-passive-event-listener</a></p><h2 id="_10-host" tabindex="-1">10. :host <a class="header-anchor" href="#_10-host" aria-label="Permalink to &quot;10. :host&quot;">​</a></h2><ol><li>:root 和 :host 的区别？</li></ol><ul><li>​​<code>:root​</code>​ 用于全局样式，定义 CSS 变量，影响整个文档。</li><li>​​<code>:host​​</code> 用于 Web Components，定义组件自身的默认样式，不影响外部 DOM。</li></ul><ol start="2"><li><code>&lt;html&gt;</code> 和 :root 有什么区别？​</li></ol><ul><li><code>html</code> 是元素选择器（优先级 0,0,1），而 <code>:root</code> 是伪类选择器（优先级 0,1,0）。</li><li><code>:root</code> 的优先级更高，适合定义全局变量。</li></ul><ol start="3"><li>:host 能访问 :root 定义的变量吗？​</li></ol><p>可以！​​ Shadow DOM 仍然能访问外部的 <code>:root</code> 变量。</p><div class="language-scss vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">scss</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 全局 CSS */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  --main-color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Shadow DOM 内部 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:host</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">--main-color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 可以使用全局变量 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="4"><li>为什么 :host 的样式有时不生效？​</li></ol><ul><li>可能是 ​​Shadow DOM 的隔离机制​​ 导致外部样式无法穿透。</li><li>可以尝试用 <code>:host-context()</code> 或 <code>::part()</code> 解决。</li></ul><h2 id="_11-t-comm-标题" tabindex="-1">11. t-comm 标题 <a class="header-anchor" href="#_11-t-comm-标题" aria-label="Permalink to &quot;11. t-comm 标题&quot;">​</a></h2><p>t-comm 文档中“引入”的标题，不能写 <code>###</code>，而要写 <code>&lt;h3&gt;</code>，前者会生成toc，后者不会。</p><h2 id="_12-picker-plus" tabindex="-1">12. picker-plus <a class="header-anchor" href="#_12-picker-plus" aria-label="Permalink to &quot;12. picker-plus&quot;">​</a></h2><p>问题：<code>picker-plus</code> 中点击确定，回调中的值不正确</p><p>原因：</p><ol><li><code>picker</code> 中有多列 <code>column</code>，<code>column</code> 在 <code>created</code> 的时候执行 <code>this[PARENT].children.push(this)</code></li><li>如果 <code>picker</code> 不销毁，<code>children</code> 也不重置，就会导致 <code>children</code> 跟实际的 <code>columns</code> 不匹配，会有额外的数据。</li></ol><p>规避：</p><p>对于业务中来说，如果 <code>columns</code> 不同，就应该用不同的 <code>picker</code>，或者用 <code>v-if</code>，主动销毁 <code>picker</code>。</p><img src="https://cdn.uwayfly.com/article/2025/8/own_mike_4QTkhRZYJ3BD4p6p.jpg" width="600"><h2 id="_13-css-中-box-shadow" tabindex="-1">13. CSS 中 box-shadow <a class="header-anchor" href="#_13-css-中-box-shadow" aria-label="Permalink to &quot;13. CSS 中 box-shadow&quot;">​</a></h2><p>语法： <code>box-shadow: offset-x offset-y blur-radius spread-radius color inset;</code></p><p><code>inset</code> 可以出现在任何位置。<code>offset-x</code> 和 <code>offset-y</code> 必填。</p><ol><li>当给出两个、三个或四个 <code>&lt;length&gt;</code> 值时。</li></ol><ul><li>如果只给出两个值，那么这两个值将会被当作 <code>&lt;offset-x&gt;&lt;offset-y&gt;</code> 来解释。</li><li>如果给出了第三个值，那么第三个值将会被当作 <code>&lt;blur-radius&gt;</code> 解释。</li><li>如果给出了第四个值，那么第四个值将会被当作 <code>&lt;spread-radius&gt;</code> 来解释。</li></ul><ol start="2"><li>可选，inset关键字。</li><li>可选，<code>&lt;color&gt;</code>值。</li></ol><ul><li><code>inset</code>： 如果没有指定inset，默认阴影在边框外，即阴影向外扩散。</li><li><code>offset-x/offset-y</code>： <code>&lt;offset-x&gt;</code> 设置水平偏移量，正值阴影则位于元素右边，负值阴影则位于元素左边。 <code>&lt;offset-y&gt;</code> 设置垂直偏移量，正值阴影则位于元素下方，负值阴影则位于元素上方。</li><li><code>blur-radius</code>：值越大，模糊面积越大，阴影就越大越淡。不能为负值。默认为 0，此时阴影边缘锐利。</li><li><code>spread-radius</code>： 取正值时，阴影扩大；取负值时，阴影收缩。默认为 0，此时阴影与元素同样大。</li></ul><h2 id="_14-cp-n" tabindex="-1">14. cp -n <a class="header-anchor" href="#_14-cp-n" aria-label="Permalink to &quot;14. cp -n&quot;">​</a></h2><p><code>cp -n</code> 是 Linux/Unix 系统中 <code>cp</code> 命令的一个选项，用于避免覆盖已存在的目标文件。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cdn-hok-match/hok-match/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cdn-hok-match/hok-match-en</span></span></code></pre></div><h2 id="_15-端口说明-port、targetport、nodeport-的区别" tabindex="-1">15. 端口说明（port、targetPort、nodePort 的区别） <a class="header-anchor" href="#_15-端口说明-port、targetport、nodeport-的区别" aria-label="Permalink to &quot;15. 端口说明（port、targetPort、nodePort 的区别）&quot;">​</a></h2><p>在 Kubernetes 中，port、targetPort 和 nodePort 都是用于配置服务端口的属性，但它们的作用和使用场景有所不同。</p><ol><li><p>port 是 Service 的端口，这是客户端访问服务时使用的端口号。Kubernetes Service 会在这个端口上监听，并将流量转发到后端 Pod 的 targetPort。例如，如果 port 设置为 9006，当客户端访问 my-service 服务时，会通过 9006 端口进行访问。</p></li><li><p>targetPort 是后端 Pod 的端口，这是实际运行服务的容器内的端口。Service 会将接收到的流量转发到后端 Pod 上这个端口。比如，如果 targetPort 设置为 9006，Kubernetes 会将 my-service 服务收到的流量转发到所有符合选择器的 Pod 的 9006 端口。</p></li><li><p>nodePort 是每个节点上的固定端口，这是一个在每个节点上开放的端口，使得可以从集群外部通过 <code>&lt;节点IP&gt;:&lt;nodePort&gt;</code> 访问服务。通常在 Service 类型为 NodePort 或 LoadBalancer 时使用。假设 nodePort 设置为 30006，这会在每个节点上开放 30006 端口，外部流量可以通过 &lt;节点IP&gt;:30006 访问服务。</p></li></ol><p>下面是一个具体的例子，展示了如何在 Kubernetes 中配置和使用 port、targetPort 和 nodePort。假设我们有一个 Service 配置，且存在以下 IP 地址：</p><p>Kubernetes 中的 Service 实际上也是一个服务对象，一般来说它有一个内部的 IP 地址（headless service “无头服务”除外），这个 IP 地址在集群内部可以访问。</p><ul><li>一个 Node 的 IP 地址是 192.168.1.1</li><li>Service 的 ClusterIP 是 10.96.0.2</li><li>一个 Pod 的 IP 地址是 10.244.1.3</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>apiVersion: v1</span></span>
<span class="line"><span>kind: Service</span></span>
<span class="line"><span>metadata:</span></span>
<span class="line"><span>  name: my-service</span></span>
<span class="line"><span>spec:</span></span>
<span class="line"><span>  type: NodePort</span></span>
<span class="line"><span>  ports:</span></span>
<span class="line"><span>    - port: 9006</span></span>
<span class="line"><span>      targetPort: 9376</span></span>
<span class="line"><span>      nodePort: 30006</span></span>
<span class="line"><span>  selector:</span></span>
<span class="line"><span>    app: MyApp</span></span></code></pre></div><ul><li>port: 9006：客户端在集群内部通过 my-service 服务名称和 9006 端口访问服务。</li><li>targetPort: 9376：实际运行服务的 Pod 内部监听的端口。</li><li>nodePort: 30006：在每个节点上开放的固定端口，允许从集群外部通过 &lt;节点IP&gt;:30006 访问服务。</li></ul><p>工作流程</p><p>集群内部访问，<code>curl http://my-service:9006</code></p><ol><li>集群内部的客户端访问 Service 时，使用 Service 名称 my-service 和端口 9006，例如：<a href="http://my-service:9006" target="_blank" rel="noreferrer">http://my-service:9006</a>。</li><li>Kubernetes 会将流量发送到 Service 的 ClusterIP 10.96.0.2:9006。</li><li>Service 接收到流量后，会将其转发到符合选择器的 Pod 的 targetPort，即 10.244.1.3:9376。</li></ol><p>集群外部访问，<code>curl http://192.168.1.1:30006</code></p><ol><li>外部客户端访问 Service 时，通过节点 IP 192.168.1.1 和 nodePort 30006，例如：<code>http://192.168.1.1:30006</code>。</li><li>流量进入节点 192.168.1.1:30006 后，Kubernetes 会将其转发到 Service 的 port，即 10.96.0.2:9006。</li><li>Service 接收到流量后，会将其转发到符合选择器的 Pod 的 targetPort，即 10.244.1.3:9376。</li></ol><p>此命令将流量发送到节点 <code>192.168.1.1:30006</code>，然后 Kubernetes 将流量转发到 Service 的 <code>port 10.96.0.2:9006</code>，最终转发到pod。</p><h2 id="_16-ingress" tabindex="-1">16. Ingress <a class="header-anchor" href="#_16-ingress" aria-label="Permalink to &quot;16. Ingress&quot;">​</a></h2><p>service 适用于「四层路由负载」，ingress 适用于「七层路由负载」。</p><p>用户首先定义 Ingress 资源，指定哪些外部请求应被路由到哪些内部服务。Ingress 资源本身只是定义了流量路由的规则，实际的流量转发则由 Ingress 控制器实现。Ingress 控制器是 Kubernetes 中的一个特殊组件，它会读取 Ingress 资源的定义，并根据这些定义动态配置自己的代理规则，管理底层的代理服务器，如 Nginx、Traefik 或 HAProxy 等。</p><p>Ingress 的主要功能包括：</p><ul><li>基于 URL 路径或主机名路由请求。</li><li>处理 HTTPS 流量的 SSL/TLS 终结。</li><li>将外部请求路由到内部服务的反向代理功能。</li><li>在多个后端 Pod 之间均匀分配流量的负载均衡。</li><li>支持配置重定向、URL 重写和基于请求头的路由等自定义规则。</li></ul><h2 id="_17-deployment" tabindex="-1">17. Deployment <a class="header-anchor" href="#_17-deployment" aria-label="Permalink to &quot;17. Deployment&quot;">​</a></h2><p>Deployment 用于部署应用程序，并且用声明的方式升级应用程序。其中，Deployment 由 <code>ReplicaSet(1:N)</code> 组成，并且由 ReplicaSet 来创建和管理 Pod。</p><h2 id="_18-service" tabindex="-1">18. Service <a class="header-anchor" href="#_18-service" aria-label="Permalink to &quot;18. Service&quot;">​</a></h2><ol><li>为什么需要服务(Service)</li></ol><ul><li><code>pod</code> 是短暂的, 随时都可能被销毁。</li><li>新的 <code>pod</code> 创建之前不能确定该 <code>pod</code> 分配的 <code>ip</code></li><li>水平伸缩也就以为着多个 <code>pod</code> 可能提供相同的服务，客户端不想也不关心每个 <code>pod</code> 的 <code>ip</code>, 相反，客户端期望通过一个单一的 <code>ip</code> 地址进行访问多个 <code>pod</code>.</li></ul><p>服务是一种为一组功能相同的 <code>pod</code> 提供单一不变的接入点的资源。当服务存在时，该服务的 <code>ip</code> 地址和端口（创建服务的时候，通过 <code>ports[n].port和ports[n].targetPort</code> 指定了服务端口到 <code>pod</code> 端口的映射）不会改变。客户端通过 <code>ip</code> 和 <code>port</code> 与服务建立连接，然后这些连接会被路由到提供该服务的某个 <code>pod</code> 上(通过负载均衡)。</p><ol start="2"><li><p>集群内部pod间通信 服务的后端可能不止有一个 pod, 服务通过标签选择器来指定哪些 pod 属于同一个组，然后连接到服务的客户端连接，服务会通过负载均衡路由到某个后端 pod。</p></li><li><p>集群内部服务暴露给外部客户端</p></li></ol><p>如果集群外部客户端需要访问集群内部的服务，则可以通过如下几种方式：</p><ul><li>NodePort类型服务</li><li>LoadBalancer类型服务</li><li>通过Ingress暴露服务（通过一个IP地址公开多个服务）</li></ul><h2 id="_19-pod" tabindex="-1">19. Pod <a class="header-anchor" href="#_19-pod" aria-label="Permalink to &quot;19. Pod&quot;">​</a></h2><ol><li>为什么需要pod</li></ol><p>前边已经提到，容器被设计为每个容器只运行一个进程，那么多个进程就不能聚集在一个单独的容器，但是容器之间是彼此完全隔离的，多个进程分布在对应的多个容器中，进程之间无法做到资源共享（比如，前边提到到生产者/消费进程，他们通过共享内存和信号量来通信，但是如果生产者进程和消费者进程分布在两个容器中，则IPC是相互隔离的，导致无法通信）。所以我们需要一种更高级的结构来将容器绑定在一起，并且将它们作为一个单元进行管理(即：多个容器间共享某些资源)，这就是为什么需要pod的根本原理。</p><ol start="2"><li>了解pod</li></ol><ul><li>可以把 pod 看作一个独立的机器，一个 pod 中可以运行一个或者多个容器，这些容器之间共享相同的ip和port空间。</li><li>一个pod的所有容器都运行在同一个 worker node 中，一个 pod 不会跨越两个 worker node.</li><li>由于大多数容器的文件系统来自于容器镜像，所以每个容器的文件系统与其他容器是完全隔离的，但是可以试用 Volume 在容器间共享文件目录。</li><li>pod 是短暂的， 他们随时的会启动或者关闭。也就是这如果某个 pod 被销毁之后，重新创建的pod的ip可能会变化。</li></ul><ol start="3"><li>Label</li></ol><p>标签是一个可以附加到资源的任意 key-value 对（一个标签就是一个 <code>key/value</code> 对，每个资源可以拥有多个标签）， 然后通过 Selector (即标签选择器)来选择具有确切标签的资源。</p><ol start="4"><li>ReplicaSet</li></ol><p>前边我们通过手工创建了 dnsutil-pod, 如果 dsnutils-pod 由于 worker node 节点失败， 那么该 pod 也会消失，并且不会被新的替换。或者如果我们想创建 n 个 dnsutil-pod，只能通过手工创建吗？答案是：ReplicaSet (即副本控制器)</p><p>ReplicaSet 是一种 k8s 资源，通过它可以保持 pod 始终按照期望的副本数量运行。如果某个 pod 因为任何原因消失，则 ReplicaSet 会注意到缺少了的 pod，并且创建新的 pod 替代它。ReplicaSet 是一种期望式声明方式，我们只需要告诉它我期望的副本数量，而不用告诉它怎么做。</p><h2 id="_20-容器" tabindex="-1">20. 容器 <a class="header-anchor" href="#_20-容器" aria-label="Permalink to &quot;20. 容器&quot;">​</a></h2><ol><li>虚拟机和容器的区别</li></ol><p>每个虚拟机运行在自己的 Linux 内核上(每个VM可以安装不同版本的 linux 系统)，而容器都是调用同一个宿主机内核。</p><ol start="2"><li>容器技术和docker的关系</li></ol><ul><li>docker用于将应用容器化。</li><li>docker是容器技术的一个分支，rkt也是一个运行容器的平台，可以作为docker的替代方案。</li></ul><ol start="3"><li>k8s 和 docker 的关系</li></ol><p>docker 是 k8s 最初唯一支持的容器类型，但是现在k8s也开始支持 rkt 以及其他的容器类型，不应该错误的认为 k8s 是一个专门为 docker 容器设计的容器编排系统。</p><ol start="4"><li>为什么多个容器比单个容器中包含多个进程要好</li></ol><p>容器之所以被设计为单个容器只运行一个进程（除非进程本身产生子进程），是因为如果单个容器中运行多个不相关的进程，那么开发人员需要保持这些所有进程都运行OK, 并且管理他们的日志等（比如，两个进程，其中一个生产者进程，一个消费者进程，如果消费者进程crash之后，我们需要考虑该进程重启的机制）。</p><img src="https://cdn.uwayfly.com/article/2025/8/own_mike_kezRn8EibyFmH5Ns.jpg" width="600"><h2 id="_21-tailwind-css-与-unocss" tabindex="-1">21. Tailwind CSS 与 UnoCSS <a class="header-anchor" href="#_21-tailwind-css-与-unocss" aria-label="Permalink to &quot;21. Tailwind CSS 与 UnoCSS&quot;">​</a></h2><ol><li><p>Tailwind CSS 是一个 CSS 框架（Library），提供了预定义的实用类（Utility Classes）。开发者可以通过组合这些类快速构建 UI。</p></li><li><p>UnoCSS 更像是一个原子 CSS 引擎（Engine），其核心是按需（on-demand）生成 CSS 的机制。通过 Preset 配置，它可以模仿 Tailwind CSS 的行为，同时也能实现其他不同的风格。</p></li></ol><img src="https://cdn.uwayfly.com/article/2025/8/own_mike_8kySPmsEjxhEyxpe.jpg" width="380"><h2 id="_22-重构" tabindex="-1">22. 重构 <a class="header-anchor" href="#_22-重构" aria-label="Permalink to &quot;22. 重构&quot;">​</a></h2><p><strong>在重构一个屎山项目时，最重要的指标就是如何保证下一次重构不会很快到来</strong>。</p><p>所以<strong>重构的技术方案中必须要包含如何让代码“保鲜”的方法，否则重构结束后，换一拨人维护几个来回，整个代码仓库又会迅速劣化成屎山</strong>。</p><img src="https://cdn.uwayfly.com/article/2025/8/own_mike_3iWnazMYJEmBhxBa.jpg" width="300"><h2 id="_23-意义" tabindex="-1">23. 意义 <a class="header-anchor" href="#_23-意义" aria-label="Permalink to &quot;23. 意义&quot;">​</a></h2><p>一个小提示，在公司里，老板们让你做的，对你的评价，以及希望你进步的方向，最大受益人是老板而不是你。如果你打算在公司里做到退休,可以按照老板们的要求做。但是如果你发现你做的这些事情对你离开公司后没有任何帮助，你就得审思一下这些事情有没有意义。得把平台的成功和自己的成功分开来。</p><img src="https://cdn.uwayfly.com/article/2025/8/own_mike_d5naXmZckpYMaaMT.jpg" width="300"><h2 id="_24-连不上办公网怎么办" tabindex="-1">24. 连不上办公网怎么办 <a class="header-anchor" href="#_24-连不上办公网怎么办" aria-label="Permalink to &quot;24. 连不上办公网怎么办&quot;">​</a></h2><p>打开目录：<code>/Library/Preferences/SystemConfiguration/</code></p><p>删除 <code>.plist</code> 后缀的文件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>com.apple.airport.preferences.plist</span></span>
<span class="line"><span>com.apple.network.identification.plist</span></span>
<span class="line"><span>com.apple.wifi.message-tracer.plist</span></span>
<span class="line"><span>NetworkInterfaces.plist</span></span>
<span class="line"><span>preferences.plist</span></span></code></pre></div><p>重启电脑，然后再在IOA重新配置 T-WiFi 看看</p><h2 id="_25-pr" tabindex="-1">25. PR <a class="header-anchor" href="#_25-pr" aria-label="Permalink to &quot;25. PR&quot;">​</a></h2><ol><li><p>PR（Pull Request）如果给其它项目提交合并代码的请求时，就说会提交一个PR。</p></li><li><p>WIP（Work In Progress ）如果你要做一个很大的改动，可以在完成部分的情况下先提交，但说明WIP，方便项目维护人员知道你还在 Work，同时他们可以先审核已经完成的。</p></li><li><p>PTAL(Please Take A Look):请求项目维护人员进行 code review。</p></li><li><p>TBR(To Be Reviewed)提示这些代码要进行审核。</p></li><li><p>TL(Too Long)/DR(Didn’t Read): 太长了，懒得看。</p></li><li><p>LGTM(Looks Good To Me):通常是 code review 的时候回复的，即审核通过的意思。</p></li><li><p>SGTM(Sounds Good To Me):跟 LGTM 同义。</p></li><li><p>AFAIK(As Far As I Know):据我所知。</p></li><li><p>CC(Carbon Copy):抄送。</p></li></ol><h2 id="_26-textellipsis" tabindex="-1">26. TextEllipsis <a class="header-anchor" href="#_26-textellipsis" aria-label="Permalink to &quot;26. TextEllipsis&quot;">​</a></h2><p>TextEllipsis 组件核心</p><ol><li><p>H5下在 <code>body</code> 下动态生成 Dom（暂称为 <code>container</code>），该DOM是不可见的，可以设置为 <code>fixed</code>，<code>zIndex</code> 和 <code>top</code> 巨低，其他样式属性和组件文本一样。具体是通过 window.getComputedStyle(this.$refs.root) 拿到 <code>offsetHeight</code>、<code>lineHeight</code>、<code>padding</code> 等值，然后设置到 <code>container</code> 上， <code>container.style.setProperty(name, originStyle.getPropertyValue(name))</code></p></li><li><p>通过上面的值判断是否需要收起，最大可展示高度 <code>maxHeight</code> 计算公式为 <code>(rows + 0.5) * lineHeight + paddingTop + paddingBottom</code>，如果 <code>maxHeight</code> 小于 <code>offsetHeight</code>，说明需要收起</p></li><li><p>省略位置的计算是通过二分法得到的，每次二分都会将当前结果加上 <code>expandText</code>（展开），插入到 <code>container</code> 的 <code>innerHtml</code> 和 <code>innerText</code> 中，这样可以获取最新的 <code>offsetHeight</code>，然后再通过第2步的公式比较</p></li><li><p>直到满足条件，即找到精确的省略位置，让文字正好占满 <code>rows</code> 行</p></li></ol><p>小程序核心</p><ol><li><p>无法动态生成 DOM，需要在组件内部先手动预埋一个 DOM</p></li><li><p>预埋的 DOM 的 <code>offsetHeight</code>、<code>lineHeight</code> 属性的获取是异步的，意味着二分法获取精确省略位置的步骤也都要变成异步</p></li><li><p>二分法中改变 <code>innerText/innerHtml</code> 的行为，在小程序下只能变成修改 DOM 内的文本变量</p></li><li><p>由于小程序文本布局和 H5 不完全相同，可能导致最后的展示效果超过了 rows 行。这里的解决办法是设置 <code>adjustString</code>，防止超行</p></li><li><p>小程序下不支持 <code>action Slot</code>。因为小程序不支持操作 <code>html</code>，所以二分法中无法将 <code>slot</code> 的 <code>html</code> 插入到 <code>container</code> 的 <code>innerHTML</code> 中，也就拿不到 slot 的具体宽度，从而找不到精确的省略位置</p></li></ol><h2 id="_27-signature" tabindex="-1">27. Signature <a class="header-anchor" href="#_27-signature" aria-label="Permalink to &quot;27. Signature&quot;">​</a></h2><p>Signature 组件的核心是 <code>touchmove</code> 的时候，获取 <code>touch</code> 的 <code>x</code> 和 <code>y</code>，然后画在 <code>canvas</code> 上。</p><h2 id="_28-barrage" tabindex="-1">28. Barrage <a class="header-anchor" href="#_28-barrage" aria-label="Permalink to &quot;28. Barrage&quot;">​</a></h2><p>Barrage 弹幕组件核心</p><ol><li>根据数据动态生成 <code>items</code>，遍历 <code>items</code>，生成 dom</li><li>动画用了 <code>animation</code>，而不是 <code>transition</code>，从 <code>translateX(110%)</code>，到 <code>translateX(var(--move-distance))</code></li><li>其中 CSS 变量 <code>--move-distance</code> 是从JS中获取外层宽度，然后设置到 <code>rootStyle</code> 中</li></ol><p>H5 和小程序实现的不同</p><ol><li>H5 可以先生成 item 的 dom，然后插入到 wrapRef 的里面，再获取其 offsetHeight，然后设置 item 的 top 值。top 值保证弹幕分层，不挤在一起。</li><li>小程序不能动态生成 dom，采用的方案是 v-for 遍历 items 数组。因为无法动态计算高度值，需要父组件额外传入 itemHeight。</li></ol><h2 id="_29-rollingtext" tabindex="-1">29. RollingText <a class="header-anchor" href="#_29-rollingtext" aria-label="Permalink to &quot;29. RollingText&quot;">​</a></h2><p>RollingText 组件</p><ol><li><p>核心是每列都生成一堆数字（figureArr），动画就是改变每列的 <code>translateY</code>，从0 到一个很小的负值（<code>translatePx</code>），或者从 <code>translatePx</code> 到 <code>0</code>，前者是向上，后者是向下。</p></li><li><p><code>translatePx</code> 就是负的单个数字的 <code>height * （figureArr.length - 1</code></p></li><li><p><code>figureArr</code> 的生成，<code>start - 9</code>, 两次 <code>0 - 9</code>，<code>0 - target</code></p></li><li><p>此外，每个数字的动画间隔，即 delay 为 <code>.2s</code></p></li></ol><h2 id="_30-copy-webpack-plugin" tabindex="-1">30. copy-webpack-plugin <a class="header-anchor" href="#_30-copy-webpack-plugin" aria-label="Permalink to &quot;30. copy-webpack-plugin&quot;">​</a></h2><p>uni-app 项目使用 pnpm 后，业务需要安装 <code>copy-webpack-plugin</code>，否则会找不到，导致版本判断失败，<code>options.patterns</code> 格式传递错误</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ValidationError: Invalid options object. Copy Plugin has been initialized using an options object that does not match the API schema.</span></span>
<span class="line"><span> - options.patterns should be a non-empty array.</span></span>
<span class="line"><span>    at validate (/data/landun/workspace/node_modules/copy-webpack-plugin/node_modules/schema-utils/dist/validate.js:158:11)</span></span>
<span class="line"><span>    at new CopyPlugin (/data/landun/workspace/node_modules/copy-webpack-plugin/dist/index.js:171:5)</span></span>
<span class="line"><span>    at /data/landun/workspace/node_modules/@dcloudio/vue-cli-plugin-uni/lib/configure-webpack.js:199:20</span></span></code></pre></div><h2 id="_31-pulldownrefresh" tabindex="-1">31. PullDownRefresh <a class="header-anchor" href="#_31-pulldownrefresh" aria-label="Permalink to &quot;31. PullDownRefresh&quot;">​</a></h2><p>PullDownRefresh 组件</p><p>onTouchMove 中，也就是下拉过程中可能产生两种状态：</p><ol><li><code>pulling</code> 下拉</li><li><code>loosing</code> 下拉距离大于 <code>loadingBarHeight</code></li></ol><p>onTouchEnd 中，会判断 status 是否为 loosing，如果是则会进入 refresh 方法</p><p><code>refresh</code> 中，会将 <code>distance</code> 置为 <code>loadingBarHeight</code>，状态置为 <code>loading</code>，然后生成一个唯一的 <code>timer</code>，利用 <code>Promise.race</code>，判断 <code>timer</code> 和 <code>onRefresh</code> 哪个返回的早，如果是 <code>onRefresh</code>, 则状态置为 <code>success</code>，否则代表超时，则恢复 <code>status</code> 为 <code>normal</code></p><h2 id="_32-pulldownrefresh" tabindex="-1">32. PullDownRefresh <a class="header-anchor" href="#_32-pulldownrefresh" aria-label="Permalink to &quot;32. PullDownRefresh&quot;">​</a></h2><p>PullDownRefresh 组件</p><p>tdesign-mobile-vue 实现不同，<code>status</code> 不直接设置，而是根据 <code>value/distance/loadingBarHeight/afterLoading</code> 等值计算而来</p><h2 id="_33-color-picker" tabindex="-1">33. Color Picker <a class="header-anchor" href="#_33-color-picker" aria-label="Permalink to &quot;33. Color Picker&quot;">​</a></h2><p>颜色选择器组件，切换 <code>saturation</code> 后，不能用 <code>update</code>，否则可能会在边界处都重置为<code>0，0，0</code>，即黑色，因为 <code>tinycolor</code> 中黑色只有一个点，而 <code>hsv</code> 中是一些线</p><h2 id="_34-非-uni-app-项目模拟-windowtop" tabindex="-1">34. 非 uni-app 项目模拟 windowTop <a class="header-anchor" href="#_34-非-uni-app-项目模拟-windowtop" aria-label="Permalink to &quot;34. 非 uni-app 项目模拟 windowTop&quot;">​</a></h2><p>设置：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.documentElement.style.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;--window-top&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;44px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>取值：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> style</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.documentElement.style;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parseInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((style.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getPropertyValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;--window-top&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;0&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><p><code>windowTop</code> 使用到的地方</p><ol><li><code>getBoundingClient()</code> 中的 <code>top</code> 和 <code>bottom</code></li><li><code>touch</code>事件中的 <code>pageY</code> <code>clientY</code></li><li><code>windowHeight</code></li></ol><h2 id="_35-import" tabindex="-1">35. @import <a class="header-anchor" href="#_35-import" aria-label="Permalink to &quot;35. @import&quot;">​</a></h2><p>uni-app 会把 <code>uni.scss</code> 放到业务每个 <code>scss</code> 前面，所以 <code>@import</code> 改成 <code>@use</code>，会报错 <code>‘@use rules must be written before any other rules’</code></p><p><code>legacy-js-api</code> 的警告，也是因为uni-app中使用了 <code>nodesass</code> 的 <code>renderSync</code></p><h2 id="_36-vue3-跨端" tabindex="-1">36. Vue3 跨端 <a class="header-anchor" href="#_36-vue3-跨端" aria-label="Permalink to &quot;36. Vue3 跨端&quot;">​</a></h2><ol><li><p>大坑，<code>$router.push({name})</code>，会有缓存，用 <code>uni.navigateTo</code> 没有</p></li><li><p>小程序 vue3 不能使用 <code>component.$scope?.setData(props)</code></p></li><li><p>不能动态引用 <code>()=import(&#39;&#39;)</code>，qq小程序的组件打包不会生成 <code>qq.createComponent</code>，而是 <code>export default</code></p></li><li><p><code>template</code> 中 <code>:key</code> 位置错误，会导致编译失败</p></li><li><p><code>location.search</code> 可能拿不到 <code>query</code>，比如 <code>#/?xxx=xxx</code>，这种不合法的 <code>query</code></p></li><li><p>vue3 app 上拿不到 <code>projectMixin</code> 上的变量</p></li><li><p>子组件中如果要抛出 <code>input</code> 和 <code>search</code> 事件，必须要声明 <code>emits</code></p></li></ol><h2 id="_37-响应式" tabindex="-1">37. 响应式 <a class="header-anchor" href="#_37-响应式" aria-label="Permalink to &quot;37. 响应式&quot;">​</a></h2><p>之前的模拟响应式用的是 <code>New Vue({ data() {}, computed: {} })</code>，比如</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      host: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      origin: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      hostname: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      pathname: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      protocol: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  computed: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    href: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;webview&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, query: { url: newVal } });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getCurUrl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDefaultUrl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    reload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      refreshCurrentPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>现在改成 <code>reactive</code> + <code>computed</code>，比如</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  host: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  origin: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  hostname: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  pathname: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  protocol: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  href: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      uni.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">navigateTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ url: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`/views/webview?url=\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newVal</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getCurUrl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDefaultUrl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }),</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  reload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    refreshCurrentPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>之前的 <code>methods</code>，现在也都是 <code>reactive</code> 的一份子</p>`,187)]))}const g=i(l,[["render",n]]);export{k as __pageData,g as default};
