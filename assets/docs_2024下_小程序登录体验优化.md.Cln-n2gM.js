import{_ as o,c,o as a,ag as d}from"./chunks/framework.6d7lLjym.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2024下/小程序登录体验优化.md","filePath":"docs/2024下/小程序登录体验优化.md","lastUpdated":1745852826000}'),i={name:"docs/2024下/小程序登录体验优化.md"};function t(p,e,r,l,h,n){return a(),c("div",null,e[0]||(e[0]=[d('<h2 id="_1-开始" tabindex="-1">1. 开始 <a class="header-anchor" href="#_1-开始" aria-label="Permalink to &quot;1. 开始&quot;">​</a></h2><p>什么是用户体验呢？一个字，爽，具体点就是，简单、自然、流畅。</p><p>基础体验优化是最重要的，之前的小程序登录体验较差，有明显的刷新页面过程，用户会感觉到页面在闪烁。</p><h2 id="_2-优化" tabindex="-1">2. 优化 <a class="header-anchor" href="#_2-优化" aria-label="Permalink to &quot;2. 优化&quot;">​</a></h2><h3 id="_2-1-现状" tabindex="-1">2.1. 现状 <a class="header-anchor" href="#_2-1-现状" aria-label="Permalink to &quot;2.1. 现状&quot;">​</a></h3><p>先说下之前的逻辑。前端请求后台接口，后台返回错误码为<code>100000</code>时，便认为是缺失了登录态。于是执行<code>wx.login</code>拿到<code>code</code>，再请求后台接口拿到登录态（<code>code</code>换<code>ticket</code>），然后将后台请求头中携带的<code>token</code>等信息种到<code>storage</code>中，然后刷新页面。下次请求从<code>storage</code>中拿到登录信息，放到<code>header</code>中，请求后台成功。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_a2d957080d4dad2f5c.png" width="550"><p>上面黄色是前端请求，粉色是后台返回，绿色和红色是前端做的。其中“刷新页面”就是这次要优化的部分。</p><p>这里是小程序官网提供的<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html" target="_blank" rel="noreferrer">时序图</a>。</p><h3 id="_2-2-装饰器-重放" tabindex="-1">2.2. 装饰器+重放 <a class="header-anchor" href="#_2-2-装饰器-重放" aria-label="Permalink to &quot;2.2. 装饰器+重放&quot;">​</a></h3><p>如何优化呢？</p><p>首先需要引入装饰器，就是对请求做一层包裹，当后台返回 <code>100000</code> 的时候，不要直接 <code>reject</code> 了，而是记录当前请求、并监听登录接口（<code>code</code>换<code>ticket</code>）的成功事件。当登录成功后再次请求刚才记录的接口，并 <code>resolve</code> 这次的返回。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_693dc0bb411861d355.png" width="550"><p>这里面有几个核心点：</p><ol><li>这里的“重放”不是完全一样的请求，不是严格意义的重放。是对刚才失败的接口再次请求，请求参数不变，但请求头会变化</li><li>要引入装饰器。因为拦截器很难做到重放，需要把它改造成异步，以及递归调用自己，还要维护一个失败队列，这会让拦截器变得很重</li><li>要注意有可能多个接口都返回了<code>100000</code>，因为接口很有可能并发执行，需要将它们分别重放</li></ol><p>说一下与上次优化的”无感登录<code>webview</code>“的区别：</p><p>登录<code>webview</code>时，<code>url</code>有额外特征（携带特殊<code>query</code>），所以可以根据这个控制接口并发为1，当请求登录成功后，就重新执行这个请求。</p><p>而小程序因为登录态有可能在任意时间失效，所以登录时机无法确定，导致并不能控制并发数为1。既然无法控制并发数，就只能在装饰器内分别记录每个请求了。</p><h3 id="_2-3-实际案例" tabindex="-1">2.3. 实际案例 <a class="header-anchor" href="#_2-3-实际案例" aria-label="Permalink to &quot;2.3. 实际案例&quot;">​</a></h3><p>下面拿个具体的页面看下。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_a347796c66c07b11b3.png" width="800"><ul><li><p>第1个请求，无需登录态，直接返回了成功。</p></li><li><p>第2-4个请求是并发执行，需要登录态，但此时登录态失效，所以都返回了 <code>100000</code>。</p></li><li><p>第5个请求，是登录接口，会执行<code>code</code>换<code>ticket</code>。</p></li><li><p>第6-8个请求，是对刚才失败的请求（第2-4个）进行的重放。</p></li></ul><p>通过上面的<code>Waterfall</code>还可以看出，<code>wx.login</code>执行也是花费了时间的，所以第4和第5个请求之间有一些间隔时间。</p><p>也可以看出登录接口（<code>code</code>换<code>ticket</code>）只返回了登录态信息，并没有返回业务信息，所以该接口仍需重放，所以这个CGI总共会被请求3次。</p><p>上面的网络请求是最理想的情况，假如换取登录态接口返回之前，还有接口返回了<code>100000</code>了，就是后一个接口在登录接口返回之前触发，由于登录态无效，它会返回<code>100000</code>，所以它也会换取登录态，<strong>之后重放那些失败了还没来得及重放的请求</strong>，所以并没有任何影响。</p><h3 id="_2-4-其他优化点" tabindex="-1">2.4. 其他优化点 <a class="header-anchor" href="#_2-4-其他优化点" aria-label="Permalink to &quot;2.4. 其他优化点&quot;">​</a></h3><p>后台提供的数据（这里是登录态）是“米”，前端只是用米做饭。好米做好饭，差米只能做差饭，没米的话就“巧妇难为无米之炊”了。</p><p>对应到这里，后台其实可以在登录接口（<code>code</code>换<code>ticket</code>）时，同时返回业务信息和登录态，而不只是登录态，这样就可以少请求一次，时间也会缩短。但可能由于历史包袱较重难以实现。</p><p>另外，前端也可以在 <code>onLaunch</code> 时，判断 <code>storage</code> 中有没有登录态相关信息，如果没有，并且业务需要登录态，那必然是要执行登录的，就可以节省一步发送探测请求的时间。</p><h2 id="_3-效果" tabindex="-1">3. 效果 <a class="header-anchor" href="#_3-效果" aria-label="Permalink to &quot;3. 效果&quot;">​</a></h2><p>下面是和平赛场之前的效果，登录后有明显的刷新页面，刷新期间页面白屏：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_19921f26ae20ec5be7.gif" width="380"><p>优化之后：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_757fb02af679f762c3.gif" width="380"><p>下面是掼蛋赛事之前的效果：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_450860049263fd4097.gif" width="380"><p>优化之后：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_88a10e6b0da491ecf3.gif" width="380"><p>赛宝一个页面之前效果：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_e8f97e5f4a20d1f66c.gif" width="380"><p>优化之后：</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_1634faa02746f4c8f7.gif" width="380"><p>当然这下面可以加骨架屏，会更自然。</p><p>要注意下，业务接入的时候，不仅要自测首页，还要测试下主流程其他页面。可以分享给其他好友，清掉缓存，然后打开转发的链接，看打开是否正常。</p><h2 id="_4-体验优化" tabindex="-1">4. 体验优化 <a class="header-anchor" href="#_4-体验优化" aria-label="Permalink to &quot;4. 体验优化&quot;">​</a></h2><p>体验优化的三个步骤：发现（对比）、分析、实践，这三个步骤可能循环往复。</p><p>体验优化和性能优化的关系是：<code>广义的体验优化 = 狭义的体验优化 + 性能优化</code>。也就是性能优化所追求的快，只是体验优化的一环，想想你的页面再快，但提供的是一坨翔，再快有意义吗？当然性能优化也很重要，是最基础的。</p><p>技术人员做体验优化，有个优势是知道产品的“边界”在哪，知道一个功能、特性、效果的实现成本、所需要的条件、制约条件是什么。</p>',48)]))}const _=o(i,[["render",t]]);export{m as __pageData,_ as default};
