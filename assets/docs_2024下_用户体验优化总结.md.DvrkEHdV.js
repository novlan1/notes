import{_ as o,c as a,o as c,ag as d}from"./chunks/framework.6d7lLjym.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2024下/用户体验优化总结.md","filePath":"docs/2024下/用户体验优化总结.md","lastUpdated":1748489149000}'),i={name:"docs/2024下/用户体验优化总结.md"};function t(r,e,l,h,n,s){return c(),a("div",null,e[0]||(e[0]=[d('<h4 id="_1-开始" tabindex="-1">1. 开始 <a class="header-anchor" href="#_1-开始" aria-label="Permalink to &quot;1. 开始&quot;">​</a></h4><p>介绍下最近做的几个用户体验优化，实现原理、效果对比、其他业务接入方式。</p><p>主要包括：</p><ol><li>无感登录 <code>webview</code>，无需刷新页面，无重复请求，等待时间大幅缩短</li><li>小程序登录优化，无页面闪烁，无重复请求，白屏时间缩短</li><li>新增下拉刷新，去掉之前的显隐重新加载，体验流畅，其他业务可快速接入</li><li>新增弹窗动画，可移植性强，可快速复用到其他业务</li></ol><h4 id="_2-无感登录-webview" tabindex="-1">2. 无感登录 webview <a class="header-anchor" href="#_2-无感登录-webview" aria-label="Permalink to &quot;2. 无感登录 webview&quot;">​</a></h4><h5 id="_2-1-背景" tabindex="-1">2.1. 背景 <a class="header-anchor" href="#_2-1-背景" aria-label="Permalink to &quot;2.1. 背景&quot;">​</a></h5><p>登录 <code>webView</code> 时，用的是 <code>sso code</code>，就是一个临时 <code>token</code>，后台拿到后，校验并返回对应的登录态信息。</p><ol><li>这个 <code>code</code> 只能用一次，用完即失效</li><li>后台优先使用 <code>url</code> 中的登录态，也就是即使你登录成功，存在有效的 <code>cookie</code>，也必须把 <code>url</code> 中的 <code>code</code> 去掉</li><li>携带有效 <code>code</code> 的请求，只会换取登录态，不再返回 CGI 业务信息</li></ol><p>由于我们的页面大部分都是并发请求，所以即使第一个接口获取到登录态后，其他接口请求也会报错。</p><h5 id="_2-2-解决并优化" tabindex="-1">2.2. 解决并优化 <a class="header-anchor" href="#_2-2-解决并优化" aria-label="Permalink to &quot;2.2. 解决并优化&quot;">​</a></h5><p>之前的前端解决方案是，用 <code>code</code> 获取到登录态之后，就刷新页面，这样就可以防止后面的接口报错。</p><p>这样的弊端就是用户体验差，有明显的刷新页面，而且换取登录态的接口的速度越慢，体验越差。如何优化呢？</p><ol><li>调度层根据当前 <code>url</code> 包含 <code>mpCode</code> 以及 <code>config.network</code> 配置，设置并发数 为 1</li><li>前端携带 <code>code</code>，请求后台接口换取登录态</li><li><code>network</code> 拦截器判断登录成功，通过 <code>history.replaceState</code> 去掉当前 <code>url</code> 的 <code>mpCode</code>，并返回特殊 <code>code</code></li><li>调度层发现特殊 <code>code</code>，重放刚才的请求，拿到真实的业务信息并返回</li><li>调度器继续执行栈中的其他请求</li><li>由于 <code>url</code> 不再包含 <code>mpCode</code>，其他请求不再控制并发数，恢复正常逻辑</li></ol><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_b9f845692775d55239.png" width="550"><p>更多技术细节可以看我的文章。</p><h5 id="_2-3-效果" tabindex="-1">2.3. 效果 <a class="header-anchor" href="#_2-3-效果" aria-label="Permalink to &quot;2.3. 效果&quot;">​</a></h5><p>左图为优化前，第一个接口请求成功后有明显的刷新页面，刷新过程页面白屏。右图为优化后，自然流畅了很多。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/4/own_mike_36f38141915087097a.gif" width="270"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/4/own_mike_986e8b3535b0e1ef4a.gif" width="270"><h5 id="_2-4-其他项目接入" tabindex="-1">2.4. 其他项目接入 <a class="header-anchor" href="#_2-4-其他项目接入" aria-label="Permalink to &quot;2.4. 其他项目接入&quot;">​</a></h5><p><strong>游戏人生网络框架</strong>内部已处理，业务无需额外接入。</p><h4 id="_3-小程序登录体验优化" tabindex="-1">3. 小程序登录体验优化 <a class="header-anchor" href="#_3-小程序登录体验优化" aria-label="Permalink to &quot;3. 小程序登录体验优化&quot;">​</a></h4><h5 id="_3-1-背景" tabindex="-1">3.1. 背景 <a class="header-anchor" href="#_3-1-背景" aria-label="Permalink to &quot;3.1. 背景&quot;">​</a></h5><p>先说下之前的逻辑。前端请求后台接口，后台返回错误码为<code>100000</code>时，便认为是缺失了登录态。于是执行<code>wx.login</code>拿到<code>code</code>，再请求后台接口拿到登录态（<code>code</code>换<code>ticket</code>），然后将后台请求头中携带的<code>token</code>等信息种到<code>storage</code>中，然后刷新页面。下次请求从<code>storage</code>中拿到登录信息，放到<code>header</code>中，请求后台成功。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_a2d957080d4dad2f5c.png" width="550"><p>上面黄色是前端请求，粉色是后台返回，绿色和红色是前端做的。其中“刷新页面”就是这次要优化的部分。</p><h5 id="_3-2-优化" tabindex="-1">3.2. 优化 <a class="header-anchor" href="#_3-2-优化" aria-label="Permalink to &quot;3.2. 优化&quot;">​</a></h5><p>首先需要引入装饰器，就是对请求做一层包裹，当后台返回 <code>100000</code> 的时候，不要直接 <code>reject</code> 了，而是记录当前请求、并监听登录接口（<code>code</code>换<code>ticket</code>）的成功事件。当登录成功后再次请求刚才记录的接口，并 <code>resolve</code> 这次的返回。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_693dc0bb411861d355.png" width="550"><p>更多技术细节可参考我的文章。</p><h5 id="_3-3-其他可优化点" tabindex="-1">3.3. 其他可优化点 <a class="header-anchor" href="#_3-3-其他可优化点" aria-label="Permalink to &quot;3.3. 其他可优化点&quot;">​</a></h5><p>后台其实可以在登录接口（<code>code</code>换<code>ticket</code>）时，同时返回业务信息和登录态，而不只是登录态，这样就可以少请求一次，时间也会缩短。但可能由于历史包袱较重难以实现。</p><p>另外，前端也可以在 <code>onLaunch</code> 时，判断 <code>storage</code> 中有没有登录态相关信息，如果没有，并且业务需要登录态，那必然是要执行登录的，就可以节省一步发送探测请求的时间。</p><h5 id="_3-4-效果" tabindex="-1">3.4. 效果 <a class="header-anchor" href="#_3-4-效果" aria-label="Permalink to &quot;3.4. 效果&quot;">​</a></h5><p>下面是和平赛场前后的效果对比。左图为优化前，登录成功后页面刷新，刷新过程页面白屏。右图为优化后，没有额外刷新，体验流畅。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_19921f26ae20ec5be7.gif" width="270"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_757fb02af679f762c3.gif" width="270"><p>下面是掼蛋赛事前后的效果对比。左图为优化前，同样的有登录成功后的页面刷新，刷新过程页面白屏。右图为优化后。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_450860049263fd4097.gif" width="270"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_88a10e6b0da491ecf3.gif" width="270"><p>赛宝一个页面前后的效果对比。左图为优化前，同样的有登录后冗余的刷新流程。右图为优化后。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_e8f97e5f4a20d1f66c.gif" width="270"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_1634faa02746f4c8f7.gif" width="270"><h5 id="_3-5-其他项目接入" tabindex="-1">3.5. 其他项目接入 <a class="header-anchor" href="#_3-5-其他项目接入" aria-label="Permalink to &quot;3.5. 其他项目接入&quot;">​</a></h5><p><strong>游戏人生网络框架</strong>内部已处理，目前业务侧只需要在 <code>config.js</code> 中配置 <code>login.notRefreshInMp</code> 为 <code>true</code>。</p><p>赛宝、和平赛事、掼蛋赛事、几个转化产品目前已接入，观察半个月无问题后，会将此优化设为默认配置。</p><h4 id="_4-下拉刷新" tabindex="-1">4. 下拉刷新 <a class="header-anchor" href="#_4-下拉刷新" aria-label="Permalink to &quot;4. 下拉刷新&quot;">​</a></h4><h5 id="_4-1-背景" tabindex="-1">4.1. 背景 <a class="header-anchor" href="#_4-1-背景" aria-label="Permalink to &quot;4.1. 背景&quot;">​</a></h5><p>观察发现，赛宝每次切换 <code>tab</code>、从二级页面返回时，首页都是重新显示 <code>loading</code>，体验较差。</p><h5 id="_4-2-优化" tabindex="-1">4.2. 优化 <a class="header-anchor" href="#_4-2-优化" aria-label="Permalink to &quot;4.2. 优化&quot;">​</a></h5><p>这里的优化方法是，取消切换<code>tab</code>、从二级页面返回后的刷新，并增加下拉刷新，即用户可以主动触发。</p><p>下拉刷新组件，已沉淀到 <code>press-ui</code> 中。</p><h5 id="_4-3-效果对比" tabindex="-1">4.3. 效果对比 <a class="header-anchor" href="#_4-3-效果对比" aria-label="Permalink to &quot;4.3. 效果对比&quot;">​</a></h5><p>左图为优化前，切换<code>tab</code>都会刷新。右图为优化后，改为用户主动下拉刷新，没有页面闪烁。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/7/own_mike_c7c34a603848303d3a.gif" width="270"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/7/own_mike_549b7e7a0b1bd46ac1.gif" width="270"><h5 id="_4-4-其他项目接入" tabindex="-1">4.4. 其他项目接入 <a class="header-anchor" href="#_4-4-其他项目接入" aria-label="Permalink to &quot;4.4. 其他项目接入&quot;">​</a></h5><p>可以参考 <code>press-ui</code> 文档，按照指引使用即可。</p><h5 id="_4-5-思考" tabindex="-1">4.5. 思考 <a class="header-anchor" href="#_4-5-思考" aria-label="Permalink to &quot;4.5. 思考&quot;">​</a></h5><p>滑动是最简单的交互（这句话其实可以细品，我们产品做的远远不够）。</p><h4 id="_5-弹窗动画" tabindex="-1">5. 弹窗动画 <a class="header-anchor" href="#_5-弹窗动画" aria-label="Permalink to &quot;5. 弹窗动画&quot;">​</a></h4><h5 id="_5-1-背景" tabindex="-1">5.1. 背景 <a class="header-anchor" href="#_5-1-背景" aria-label="Permalink to &quot;5.1. 背景&quot;">​</a></h5><p>观察发现，和平赛事项目的 <code>dialog</code>、<code>popup</code> 这些都比较生硬，不够顺滑。</p><h5 id="_5-2-优化" tabindex="-1">5.2. 优化 <a class="header-anchor" href="#_5-2-优化" aria-label="Permalink to &quot;5.2. 优化&quot;">​</a></h5><p>这种其实就是缺少了动画，要加也非常简单，无非是 <code>transition</code>。但这里考虑的是：</p><ol><li>改造简单，业务侧尽量无感知、少感知</li><li>方案可复制，能移植到团队所有业务中（因为其他业务也有弹窗效果生硬的问题）</li></ol><p>目前采用的方法是直接使用 <code>press-ui</code> 中的 <code>press-popup-plus</code> 组件，就是这么简单，用简单的方式解决简单（或复杂）的事。</p><h5 id="_5-3-效果对比" tabindex="-1">5.3. 效果对比 <a class="header-anchor" href="#_5-3-效果对比" aria-label="Permalink to &quot;5.3. 效果对比&quot;">​</a></h5><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_e24f03a30bf7bf5b14.gif" width="270"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/11/own_mike_eb88d55af3a888deb0.gif" width="270"><h5 id="_5-4-思想" tabindex="-1">5.4. 思想 <a class="header-anchor" href="#_5-4-思想" aria-label="Permalink to &quot;5.4. 思想&quot;">​</a></h5><p>这里背后的思想比原理更重要，要把显示隐藏的控制权交给子组件，而不是在页面（或父组件）控制，就是不要用 <code>v-if</code>，而是 <code>:show=&quot;&quot;</code>，这样的好处是消失的时候才有动画，即便页面（父组件）想要主动关闭也是有动画的。</p><h5 id="_5-5-其他项目接入" tabindex="-1">5.5. 其他项目接入 <a class="header-anchor" href="#_5-5-其他项目接入" aria-label="Permalink to &quot;5.5. 其他项目接入&quot;">​</a></h5><p>可以参考 <code>press-ui</code> 文档，按照指引使用即可。</p><h4 id="_6-总结" tabindex="-1">6. 总结 <a class="header-anchor" href="#_6-总结" aria-label="Permalink to &quot;6. 总结&quot;">​</a></h4><p>体验优化的三个步骤：发现（对比）、分析、实践，这三个步骤可能循环往复。</p><p>技术人员做体验优化，有个优势是知道产品的“边界”在哪，知道一个功能、特性、效果的实现成本、制约条件是什么。</p>',77)]))}const m=o(i,[["render",t]]);export{u as __pageData,m as default};
