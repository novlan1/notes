import{_ as a,c as n,o as e,ag as i}from"./chunks/framework.6d7lLjym.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2022上/Docker入门.md","filePath":"docs/2022上/Docker入门.md","lastUpdated":1745423492000}'),p={name:"docs/2022上/Docker入门.md"};function l(t,s,c,o,r,d){return e(),n("div",null,s[0]||(s[0]=[i(`<h2 id="一、开始" tabindex="-1">一、开始 <a class="header-anchor" href="#一、开始" aria-label="Permalink to &quot;一、开始&quot;">​</a></h2><p>本文讲解 Docker 的基本用法。</p><h2 id="二、docker-用法" tabindex="-1">二、Docker 用法 <a class="header-anchor" href="#二、docker-用法" aria-label="Permalink to &quot;二、Docker 用法&quot;">​</a></h2><h3 id="_1-概念" tabindex="-1">1. 概念 <a class="header-anchor" href="#_1-概念" aria-label="Permalink to &quot;1. 概念&quot;">​</a></h3><p>Docker 中有两个重要概念。</p><p>一个是镜像（Image）：镜像是一个文件，它是用来创建容器的，像<code>“Win7纯净版.rar”</code>文件。</p><p>另一个是容器（Container）：容器特别像一个虚拟机，容器中运行着一个完整的操作系统。可以在容器中装 Nodejs，可以执行 <code>npm install</code>，可以做一切你当前操作系统能做的事情。</p><p>另外，当前使用的真实操作系统称为“宿主机”(Host)</p><p>镜像是通过一个 Dockerfile 打包来的，它非常像我们前端的 <code>package.json</code> 文件。创建关系为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Dockerfile: 类似于“package.json”</span></span>
<span class="line"><span> |</span></span>
<span class="line"><span> V</span></span>
<span class="line"><span>Image: 类似于“Win7纯净版.rar”</span></span>
<span class="line"><span> |</span></span>
<span class="line"><span> V</span></span>
<span class="line"><span>Container: 一个完整操作系统</span></span></code></pre></div><h3 id="_2-前端项目打包" tabindex="-1">2. 前端项目打包 <a class="header-anchor" href="#_2-前端项目打包" aria-label="Permalink to &quot;2. 前端项目打包&quot;">​</a></h3><h4 id="_1-下载" tabindex="-1">（1）下载 <a class="header-anchor" href="#_1-下载" aria-label="Permalink to &quot;（1）下载&quot;">​</a></h4><p>官网下载 Docker Desktop。</p><h4 id="_2-初始化" tabindex="-1">（2）初始化 <a class="header-anchor" href="#_2-初始化" aria-label="Permalink to &quot;（2）初始化&quot;">​</a></h4><p>我们可以新建一个文件夹 <code>test-docker</code>，添加一个 <code>index.html</code>，随便写点什么，然后添加 <code>Dockerfile</code> 文件：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 基于哪个镜像</span></span>
<span class="line"><span>FROM nginx </span></span>
<span class="line"><span></span></span>
<span class="line"><span># 将宿主机中的./index.html文件复制进容器里的/usr/share/nginx/html/index.html</span></span>
<span class="line"><span>COPY ./index.html /usr/share/nginx/html/index.html</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 容器对外暴露80端口</span></span>
<span class="line"><span>EXPOSE 80</span></span></code></pre></div><p>COPY有个要注意的点是，复制目录的时候要把dest的目录也写上，比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>COPY server/ /usr/src/nodejs/server</span></span></code></pre></div><p>不能：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>COPY server/ /usr/src/nodejs/</span></span></code></pre></div><p>这一点和 Shell 命令还不太一样。</p><h4 id="_3-打包镜像" tabindex="-1">（3）打包镜像 <a class="header-anchor" href="#_3-打包镜像" aria-label="Permalink to &quot;（3）打包镜像&quot;">​</a></h4><p>接下来可以对我们的测试文件夹打镜像：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cd test-docker</span></span>
<span class="line"><span>docker build -t test-docker:1.0.0 .</span></span></code></pre></div><p>build 命令用来制作镜像，<code>-t</code> 是给镜像打标签，<code>-f</code> 参数是指定 Dockerfile 路径，由于我们使用的是默认 Dockerfile 名称，所以可以不同填写该参数。最后一个<code>.</code>也不要省略，表示 Dockerfile 文件的所在目录，代表是当前路径，它指定镜像构建的上下文。</p><h4 id="_4-创建容器并运行" tabindex="-1">（4）创建容器并运行 <a class="header-anchor" href="#_4-创建容器并运行" aria-label="Permalink to &quot;（4）创建容器并运行&quot;">​</a></h4><p>然后通过镜像 test-docker 创建一个容器并运行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker run --name test-docker -d -p 3000:80 test-docker:1.0.0</span></span></code></pre></div><p>说明：创建的容器名称是 test-docker，你可以理解为 pid，这个名称唯一，创建之后如果不删除会一直存在。<code>-p</code> 用来指定端口映射，将容器的端口3000映射到主机<code>80</code>端口上，这样就可外部访问了。</p><p>然后在当前主机的浏览器中打开 <code>localhost:3000</code>，就可以看到我们的 <code>index.html</code> 内容了。</p><h4 id="_5-容器调试" tabindex="-1">（5）容器调试 <a class="header-anchor" href="#_5-容器调试" aria-label="Permalink to &quot;（5）容器调试&quot;">​</a></h4><p>可以进入容器内部：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker ls -a # 查看所有容器，包括当前容器的id</span></span>
<span class="line"><span>docker exec -it &lt;id&gt; bash</span></span></code></pre></div><p>原理实际上是启动了容器内的<code>/bin/bash</code>，此时你就可以通过<code>bash shell</code>与容器内交互了。就像远程连接了 SSH 一样。</p><p>也可以查看容器日志：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker logs -f &lt;id&gt; # 容器id</span></span></code></pre></div><p>上面是对静态资源的打包，其实普通的 Vue、React 项目的打包也是一样，不过要 COPY 下打包文件夹下的文件就好了，这样可以让镜像体积更小。</p><h3 id="_3-node-项目打包" tabindex="-1">3. Node 项目打包 <a class="header-anchor" href="#_3-node-项目打包" aria-label="Permalink to &quot;3. Node 项目打包&quot;">​</a></h3><p>对于 NodeJS 项目，比如 Koa 或者 Express 这些，和静态资源的区别只是它们需要起个服务，占个端口。</p><p>对于 Docker 来说，只要改 Dockerfile 文件，其他步骤是一样的。</p><p>这里也是新建个 Koa 服务，来测试下。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// server.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Koa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;koa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> app</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Koa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ctx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Hello World&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># Dockerfile</span></span>
<span class="line"><span>FROM node:14.15.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 在容器中创建一个目录</span></span>
<span class="line"><span>RUN mkdir -p /usr/src/nodejs/</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 定位到容器的工作目录</span></span>
<span class="line"><span>WORKDIR /usr/src/nodejs/</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 把当前目录下的所有文件拷贝到 Image 的 /usr/src/nodejs/ 目录下</span></span>
<span class="line"><span>COPY . /usr/src/nodejs/</span></span>
<span class="line"><span></span></span>
<span class="line"><span>EXPOSE 3000</span></span>
<span class="line"><span>CMD npm start</span></span></code></pre></div><h3 id="_4-docker-命令" tabindex="-1">4. docker 命令 <a class="header-anchor" href="#_4-docker-命令" aria-label="Permalink to &quot;4. docker 命令&quot;">​</a></h3><p>镜像相关：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker pull [镜像名称:版本] # 拉取镜像</span></span>
<span class="line"><span>docker images  # 镜像列表</span></span>
<span class="line"><span>docker rmi [镜像名称:版本] # 删除镜像</span></span>
<span class="line"><span>docker history [镜像名称:版本] # 镜像操作记录</span></span>
<span class="line"><span>docker tag [镜像名称:版本][新镜像名称:新版本]</span></span>
<span class="line"><span>docker inspect [镜像名称:版本] # 查看镜像详细</span></span>
<span class="line"><span>docker search [关键字] # 搜索镜像</span></span>
<span class="line"><span>docker login # docker hub 登陆</span></span>
<span class="line"><span>docker logout # docker hub 登陆</span></span></code></pre></div><p>容器相关：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker ps -a # 容器列表(所有容器)</span></span>
<span class="line"><span>docker ps  # 查看所有(运行的)容器</span></span>
<span class="line"><span>docker exec -ti &lt;id&gt; bash  # 以 bash 命令进入容器内</span></span>
<span class="line"><span>docker run -ti --name [容器名称][镜像名称:版本] bash # 启动容器并进入</span></span>
<span class="line"><span>docker logs &lt;container_id&gt; # 查看容器日志</span></span>
<span class="line"><span>docker top &lt;container_id&gt; # 查看容器最近的一个进程</span></span>
<span class="line"><span>docker run -ti --name [容器名称] -p 8080:80 [镜像名称:版本] bash  # 端口映射</span></span>
<span class="line"><span>docker rm &lt;container_id&gt; # 删除容器</span></span>
<span class="line"><span>docker stop &lt;container_id&gt; # 停止容器</span></span>
<span class="line"><span>docker start &lt;container_id&gt; # 开启容器</span></span>
<span class="line"><span>docker restart &lt;container_id&gt; # 重启容器</span></span>
<span class="line"><span>docker inspect &lt;container_id&gt; # 查看容器详情</span></span>
<span class="line"><span>docker commit [容器名称] my_image:v1.0  # 容器提交为新的镜像</span></span></code></pre></div><h2 id="三、docker-hub-限频问题" tabindex="-1">三、Docker hub 限频问题 <a class="header-anchor" href="#三、docker-hub-限频问题" aria-label="Permalink to &quot;三、Docker hub 限频问题&quot;">​</a></h2><p>如果在拉取镜像等操作时遇到限频问题，可以添加镜像，并重启 Docker：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;registry-mirrors&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;https://hub-mirror.c.163.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;https://mirror.baidubce.com&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="四、相关资料" tabindex="-1">四、相关资料 <a class="header-anchor" href="#四、相关资料" aria-label="Permalink to &quot;四、相关资料&quot;">​</a></h2><ol><li><a href="https://juejin.cn/post/6844904035053486087" target="_blank" rel="noreferrer">Docker 搭建你的第一个 Node 项目到服务器</a></li><li><a href="https://juejin.cn/post/6844904081966759943" target="_blank" rel="noreferrer">看完这篇，再也不用焦虑如何写dockerfile了</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/install/mirror#macos" target="_blank" rel="noreferrer">Docker —— 从入门到实践</a></li><li><a href="https://blog.csdn.net/zisefeizhu/article/details/83472190" target="_blank" rel="noreferrer">dockerfile详解</a></li><li><a href="https://blog.csdn.net/claram/article/details/104228727" target="_blank" rel="noreferrer">docker run 命令的 -i -t -d选项的作用</a></li></ol>`,53)]))}const g=a(p,[["render",l]]);export{k as __pageData,g as default};
