import{_ as p,C as r,c as h,o as a,a2 as e,b as n,w as t,a as o,G as l,a3 as d}from"./chunks/framework.CriqKoQt.js";const B=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2026上/tdesign-e2e-test.md","filePath":"docs/2026上/tdesign-e2e-test.md","lastUpdated":1770697192000}'),c={name:"docs/2026上/tdesign-e2e-test.md"};function g(E,s,k,A,u,b){const i=r("Mermaid");return a(),h("div",null,[s[2]||(s[2]=e('<h2 id="一、项目背景" tabindex="-1">一、项目背景 <a class="header-anchor" href="#一、项目背景" aria-label="Permalink to &quot;一、项目背景&quot;">​</a></h2><p><a href="https://tdesign.tencent.com/" target="_blank" rel="noreferrer">TDesign</a> 是腾讯开源的企业级设计体系，覆盖了 Vue Next、UniApp、小程序、Mobile Vue 等多个技术栈，其官网承载着大量组件文档页面。随着站点规模增长，一个核心风险始终存在——<strong>页面发布后白屏</strong>或<strong>关键元素丢失</strong>。手工巡检不现实，传统的单元测试又覆盖不到真实浏览器的渲染链路。</p><p><a href="https://github.com/TDesignOteam/tdesign-e2e-test" target="_blank" rel="noreferrer">tdesign-e2e-test</a> 正是为解决这一问题而设计的：基于 <strong>Puppeteer + Jest</strong>，通过 <strong>纯配置驱动</strong> 的方式，让开发者只需编写 JSON 风格的配置对象，即可自动生成完整的 E2E 测试用例，<strong>零测试代码编写</strong>。</p><hr><h2 id="二、整体架构" tabindex="-1">二、整体架构 <a class="header-anchor" href="#二、整体架构" aria-label="Permalink to &quot;二、整体架构&quot;">​</a></h2><p>项目采用 <strong>&quot;配置层 → 引擎层 → 工具层&quot;</strong> 三层架构，各层职责清晰、互不耦合：</p>',6)),(a(),n(d,null,{default:t(()=>[l(i,{id:"mermaid-17",class:"mermaid my-mermaid-class",graph:"graph%20TB%0A%20%20%20%20subgraph%20%E9%85%8D%E7%BD%AE%E5%B1%82%5B%22%F0%9F%93%82%20%E9%85%8D%E7%BD%AE%E5%B1%82%20(tests%2Fconfig%2F)%22%5D%0A%20%20%20%20%20%20%20%20types%5B%22types.ts%3Cbr%2F%3E%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%22%5D%0A%20%20%20%20%20%20%20%20modules%5B%22modules%2F%3Cbr%2F%3E%E6%A8%A1%E5%9D%97%E5%8C%96%E9%85%8D%E7%BD%AE%22%5D%0A%20%20%20%20%20%20%20%20entry%5B%22pages.config.ts%3Cbr%2F%3E%E9%85%8D%E7%BD%AE%E6%B1%87%E6%80%BB%E5%85%A5%E5%8F%A3%22%5D%0A%20%20%20%20%20%20%20%20modules%20--%3E%20entry%0A%20%20%20%20%20%20%20%20types%20-.-%3E%20modules%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%E5%BC%95%E6%93%8E%E5%B1%82%5B%22%E2%9A%99%EF%B8%8F%20%E5%BC%95%E6%93%8E%E5%B1%82%20(tests%2F)%22%5D%0A%20%20%20%20%20%20%20%20spec%5B%22tdesign.spec.ts%3Cbr%2F%3E%E6%B5%8B%E8%AF%95%E5%BC%95%E6%93%8E%3Cbr%2F%3E%E8%87%AA%E5%8A%A8%E9%81%8D%E5%8E%86%E9%85%8D%E7%BD%AE%20%E2%86%92%20%E7%94%9F%E6%88%90%E7%94%A8%E4%BE%8B%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%E5%B7%A5%E5%85%B7%E5%B1%82%5B%22%F0%9F%94%A7%20%E5%B7%A5%E5%85%B7%E5%B1%82%20(tests%2Futils%2F)%22%5D%0A%20%20%20%20%20%20%20%20helpers%5B%22helpers.ts%3Cbr%2F%3E%E7%99%BD%E5%B1%8F%E6%A3%80%E6%B5%8B%20%2F%20%E5%85%83%E7%B4%A0%E6%A3%80%E6%B5%8B%3Cbr%2F%3EShadow%20DOM%20%E7%A9%BF%E9%80%8F%3Cbr%2F%3E%E6%93%8D%E4%BD%9C%E6%89%A7%E8%A1%8C%E5%99%A8%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20CI%5B%22%F0%9F%9A%80%20CI%2FCD%22%5D%0A%20%20%20%20%20%20%20%20workflow%5B%22GitHub%20Actions%3Cbr%2F%3E%E5%AE%9A%E6%97%B6%20%2B%20Push%20%E8%A7%A6%E5%8F%91%22%5D%0A%20%20%20%20%20%20%20%20notify%5B%22scripts%2Fnotify.ts%3Cbr%2F%3E%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%80%9A%E7%9F%A5%22%5D%0A%20%20%20%20%20%20%20%20workflow%20--%3E%20notify%0A%20%20%20%20end%0A%0A%20%20%20%20entry%20--%3E%20spec%0A%20%20%20%20spec%20--%3E%20helpers%0A%20%20%20%20spec%20--%3E%20CI%0A"})]),fallback:t(()=>s[0]||(s[0]=[o(" Loading... ")])),_:1})),s[3]||(s[3]=e(`<h3 id="_2-1-配置层-声明式描述-测什么" tabindex="-1">2.1 配置层：声明式描述&quot;测什么&quot; <a class="header-anchor" href="#_2-1-配置层-声明式描述-测什么" aria-label="Permalink to &quot;2.1 配置层：声明式描述&quot;测什么&quot;&quot;">​</a></h3><p>配置层是用户唯一需要关注的部分。核心类型 <code>PageConfig</code> 定义了一个测试用例的完整描述：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PageConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用例名称</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  url</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;                 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 目标页面</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  whiteScreenCheck</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是否白屏检测</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  expectedSelectors</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 期望存在的元素</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  actions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PageAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[];      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 操作序列（点击/悬浮/导航/滚动/输入）</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  afterActionCheck</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AfterActionCheck</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 操作后校验</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  viewport</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自定义视口</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  skip</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 跳过标记</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>使用者只需填写配置对象，<strong>不需要编写任何 <code>test()</code>、<code>expect()</code> 代码</strong>。框架会自动将每条配置映射为一个独立的 Jest 测试用例。</p><h3 id="_2-2-引擎层-自动化遍历-用例生成" tabindex="-1">2.2 引擎层：自动化遍历 + 用例生成 <a class="header-anchor" href="#_2-2-引擎层-自动化遍历-用例生成" aria-label="Permalink to &quot;2.2 引擎层：自动化遍历 + 用例生成&quot;">​</a></h3><p><code>tdesign.spec.ts</code> 是整个框架的&quot;心脏&quot;，核心逻辑仅约 120 行，但完成了以下工作：</p><ol><li><strong>启动浏览器</strong>：<code>beforeAll</code> 中初始化 Puppeteer，CI 环境自动切换 headless 模式</li><li><strong>遍历配置、生成用例</strong>：<code>for (const pageConfig of pagesConfig)</code> 循环，为每条配置动态生成 <code>test()</code></li><li><strong>标准化测试流程</strong>：每个用例按统一管线执行——设置视口 → 注册错误收集 → 访问页面 → 等待网络空闲 → 白屏检测 → 元素检测 → 执行操作 → 操作后校验</li><li><strong>资源管理</strong>：每个用例独立开启/关闭 Page，<code>afterAll</code> 中关闭浏览器，杜绝内存泄漏</li></ol><p>这种设计让引擎层成为&quot;不可变的骨架&quot;——<strong>新增测试用例永远不需要修改引擎代码</strong>。</p><h3 id="_2-3-工具层-对抗-web-components-的深度穿透" tabindex="-1">2.3 工具层：对抗 Web Components 的深度穿透 <a class="header-anchor" href="#_2-3-工具层-对抗-web-components-的深度穿透" aria-label="Permalink to &quot;2.3 工具层：对抗 Web Components 的深度穿透&quot;">​</a></h3><p>TDesign 官网大量使用了 Web Components + Shadow DOM（如 <code>&lt;td-header&gt;</code>、<code>&lt;td-doc-layout&gt;</code>），传统的 <code>document.querySelector</code> 无法穿透 Shadow DOM 边界。</p><p><code>helpers.ts</code> 中实现了一套 <strong>递归穿透 Shadow DOM 的选择器引擎</strong>，这是整个项目最有技术含量的部分：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>deepQuerySelector(page, selector)</span></span>
<span class="line"><span>│</span></span>
<span class="line"><span>├── 普通选择器 &quot;.TDesign-header&quot;</span></span>
<span class="line"><span>│   └── 递归遍历所有 ShadowRoot + Slot 分发内容</span></span>
<span class="line"><span>│</span></span>
<span class="line"><span>└── 穿透组合选择器 &quot;td-header &gt;&gt;&gt; .TDesign-header-nav&quot;</span></span>
<span class="line"><span>    └── 按 &quot;&gt;&gt;&gt;&quot; 分段，逐层进入 Shadow DOM</span></span></code></pre></div><p>此外，<code>waitForVisible()</code> 实现了轮询等待机制，不仅检查元素存在，还验证其真实可见性（<code>getBoundingClientRect</code> + <code>getComputedStyle</code>），避免 <code>display:none</code> 或零尺寸元素的误判。</p><p><strong>白屏检测</strong> 采用 4 层递进策略：</p><table tabindex="0"><thead><tr><th>层级</th><th>检测项</th><th>目的</th></tr></thead><tbody><tr><td>1</td><td><code>body.children.length &gt; 0</code></td><td>排除完全空白页</td></tr><tr><td>2</td><td><code>body.innerHTML.length &gt; 50</code></td><td>排除仅有空标签壳</td></tr><tr><td>3</td><td>递归穿透 Shadow DOM 找可见内容</td><td>排除 Web Components 内部白屏</td></tr><tr><td>4</td><td>检查 SPA 根挂载点 + 自定义元素</td><td>排除框架未挂载</td></tr></tbody></table><p>四层策略相互补充，既能检测传统 SPA 白屏，也能覆盖 Web Components 场景。</p><hr><h2 id="三、灵活的配置方式" tabindex="-1">三、灵活的配置方式 <a class="header-anchor" href="#三、灵活的配置方式" aria-label="Permalink to &quot;三、灵活的配置方式&quot;">​</a></h2><h3 id="_3-1-五种操作类型覆盖主流交互" tabindex="-1">3.1 五种操作类型覆盖主流交互 <a class="header-anchor" href="#_3-1-五种操作类型覆盖主流交互" aria-label="Permalink to &quot;3.1 五种操作类型覆盖主流交互&quot;">​</a></h3><p>框架内置了 5 种操作类型，通过组合使用可以模拟几乎所有用户交互场景：</p><table tabindex="0"><thead><tr><th>类型</th><th>用途</th><th>关键参数</th></tr></thead><tbody><tr><td><code>click</code></td><td>点击元素，支持自动等待导航</td><td><code>selector</code></td></tr><tr><td><code>hover</code></td><td>鼠标悬浮，验证浮层/下拉菜单</td><td><code>selector</code></td></tr><tr><td><code>navigate</code></td><td>SPA 路由跳转</td><td><code>targetUrl</code></td></tr><tr><td><code>scroll</code></td><td>页面滚动，测试懒加载</td><td><code>scrollY</code></td></tr><tr><td><code>input</code></td><td>文本输入，测试搜索/表单</td><td><code>selector</code> + <code>inputValue</code></td></tr></tbody></table><p>操作支持 <code>waitBefore</code> / <code>waitAfter</code> 精细控制时序，也支持链式组合——先滚动、再点击、再输入，一气呵成。</p><h3 id="_3-2-shadow-dom-穿透选择器" tabindex="-1">3.2 Shadow DOM 穿透选择器 <a class="header-anchor" href="#_3-2-shadow-dom-穿透选择器" aria-label="Permalink to &quot;3.2 Shadow DOM 穿透选择器&quot;">​</a></h3><p>针对 Web Components，框架设计了直观的 <code>&gt;&gt;&gt;</code> 穿透语法：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 先找到 &lt;td-header&gt;，进入其 Shadow DOM，再找 .TDesign-header-nav</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;td-header &gt;&gt;&gt; .TDesign-header-nav&#39;</span></span></code></pre></div><p>普通选择器则自动递归穿透所有层级的 Shadow DOM，开发者无需关心元素在哪一层。</p><h3 id="_3-3-操作后校验" tabindex="-1">3.3 操作后校验 <a class="header-anchor" href="#_3-3-操作后校验" aria-label="Permalink to &quot;3.3 操作后校验&quot;">​</a></h3><p>每条配置可以附带 <code>afterActionCheck</code>，在操作执行后自动验证：</p><ul><li><strong>白屏检测</strong>：操作后页面是否正常渲染</li><li><strong>元素检测</strong>：操作后目标元素是否出现</li><li><strong>URL 校验</strong>：通过正则匹配验证跳转是否正确</li></ul><hr><h2 id="四、可扩展性设计" tabindex="-1">四、可扩展性设计 <a class="header-anchor" href="#四、可扩展性设计" aria-label="Permalink to &quot;四、可扩展性设计&quot;">​</a></h2><h3 id="_4-1-模块化拆分" tabindex="-1">4.1 模块化拆分 <a class="header-anchor" href="#_4-1-模块化拆分" aria-label="Permalink to &quot;4.1 模块化拆分&quot;">​</a></h3><p>配置按 TDesign 子站拆分为独立模块，存放在 <code>tests/config/modules/</code> 目录下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>modules/</span></span>
<span class="line"><span>├── index.ts           ← 统一导出</span></span>
<span class="line"><span>├── home.ts            ← 官网首页</span></span>
<span class="line"><span>├── uniapp.ts          ← UniApp</span></span>
<span class="line"><span>├── miniprogram.ts     ← 小程序</span></span>
<span class="line"><span>├── vue-next.ts        ← Vue Next (桌面端)</span></span>
<span class="line"><span>└── mobile-vue.ts      ← Mobile Vue (移动端)</span></span></code></pre></div><p><code>pages.config.ts</code> 作为汇总入口，通过展开运算符合并所有模块：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PageConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">homePages,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uniappPages,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">miniprogramPages,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vueNextPages,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mobileVuePages,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span></code></pre></div><h3 id="_4-2-新增模块只需-3-步" tabindex="-1">4.2 新增模块只需 3 步 <a class="header-anchor" href="#_4-2-新增模块只需-3-步" aria-label="Permalink to &quot;4.2 新增模块只需 3 步&quot;">​</a></h3><p>以新增 React 模块为例：</p><ol><li><strong>创建</strong> <code>modules/react.ts</code>，导出 <code>PageConfig[]</code> 数组</li><li><strong>注册</strong> 在 <code>modules/index.ts</code> 中添加一行 <code>export</code></li><li><strong>合并</strong> 在 <code>pages.config.ts</code> 中展开 <code>...reactPages</code></li></ol><p>整个过程不需要修改引擎代码、不需要新建测试文件、不需要改动 CI 配置。</p><h3 id="_4-3-新增操作类型" tabindex="-1">4.3 新增操作类型 <a class="header-anchor" href="#_4-3-新增操作类型" aria-label="Permalink to &quot;4.3 新增操作类型&quot;">​</a></h3><p>如果未来需要支持新的交互（如拖拽、长按），只需：</p><ol><li>在 <code>PageAction.type</code> 联合类型中新增枚举值</li><li>在 <code>helpers.ts</code> 的 <code>executeActions</code> 中新增 <code>case</code> 分支</li></ol><p>引擎层和配置层完全不受影响，体现了 <strong>开闭原则（OCP）</strong>。</p><hr><h2 id="五、易维护性" tabindex="-1">五、易维护性 <a class="header-anchor" href="#五、易维护性" aria-label="Permalink to &quot;五、易维护性&quot;">​</a></h2><h3 id="_5-1-typescript-全链路类型安全" tabindex="-1">5.1 TypeScript 全链路类型安全 <a class="header-anchor" href="#_5-1-typescript-全链路类型安全" aria-label="Permalink to &quot;5.1 TypeScript 全链路类型安全&quot;">​</a></h3><p>从配置定义到引擎消费，全程 TypeScript 强类型。<code>PageConfig</code> 接口确保：</p><ul><li>拼错字段名 → 编译报错</li><li>遗漏必填字段 → 编译报错</li><li><code>action.type</code> 传入未知值 → 编译报错</li></ul><p>类型系统充当了&quot;活文档&quot;，开发者阅读接口定义即可理解所有配置项。</p><h3 id="_5-2-配置与代码完全解耦" tabindex="-1">5.2 配置与代码完全解耦 <a class="header-anchor" href="#_5-2-配置与代码完全解耦" aria-label="Permalink to &quot;5.2 配置与代码完全解耦&quot;">​</a></h3><p>这是项目最核心的设计理念：<strong>测试逻辑是稳定的框架代码，测试内容是可变的配置数据</strong>。</p><ul><li>新增页面？→ 只改配置</li><li>页面改版？→ 只改选择器</li><li>新增检测维度？→ 只改工具函数</li></ul><p>三个变更方向互不干扰，团队中不同角色可以并行工作。</p><h3 id="_5-3-自动化-ci-cd-告警闭环" tabindex="-1">5.3 自动化 CI/CD + 告警闭环 <a class="header-anchor" href="#_5-3-自动化-ci-cd-告警闭环" aria-label="Permalink to &quot;5.3 自动化 CI/CD + 告警闭环&quot;">​</a></h3><p>项目集成了 <a href="/notes/Users/guowangyang/Documents/github/tdesign-e2e/.github/workflows/e2e-test.yml">GitHub Actions 工作流</a>，实现了完整的自动化闭环：</p>`,56)),(a(),n(d,null,{default:t(()=>[l(i,{id:"mermaid-381",class:"mermaid my-mermaid-class",graph:"graph%20LR%0A%20%20%20%20A%5B%22%E2%8F%B0%20%E5%AE%9A%E6%97%B6%E8%A7%A6%E5%8F%91%3Cbr%2F%3E%E6%AF%8F%2010%20%E5%88%86%E9%92%9F%22%5D%20--%3E%20B%5B%22%F0%9F%A7%AA%20%E6%89%A7%E8%A1%8C%20E2E%20%E6%B5%8B%E8%AF%95%22%5D%0A%20%20%20%20C%5B%22%F0%9F%93%A6%20master%20Push%22%5D%20--%3E%20B%0A%20%20%20%20D%5B%22%F0%9F%96%B1%EF%B8%8F%20%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%22%5D%20--%3E%20B%0A%20%20%20%20B%20--%3E%7C%E9%80%9A%E8%BF%87%7C%20E%5B%22%E2%9C%85%20%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%22%5D%0A%20%20%20%20B%20--%3E%7C%E5%A4%B1%E8%B4%A5%7C%20F%5B%22%F0%9F%93%A4%20%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%80%9A%E7%9F%A5%3Cbr%2F%3E%E5%A4%B1%E8%B4%A5%E7%94%A8%E4%BE%8B%20%2B%20Actions%20%E9%93%BE%E6%8E%A5%22%5D%0A%20%20%20%20F%20--%3E%20E%0A"})]),fallback:t(()=>s[1]||(s[1]=[o(" Loading... ")])),_:1})),s[4]||(s[4]=e('<p><code>notify.ts</code> 通知脚本会自动解析 Jest JSON 输出，提取失败用例的名称和错误信息，格式化为 Markdown 消息推送到企业微信，包含直达 Actions 日志的链接。</p><h3 id="_5-4-容错设计" tabindex="-1">5.4 容错设计 <a class="header-anchor" href="#_5-4-容错设计" aria-label="Permalink to &quot;5.4 容错设计&quot;">​</a></h3><p>框架在多处做了容错处理，保证单个用例失败不会拖垮整个测试：</p><ul><li><code>networkIdle</code> 超时不阻塞测试（<code>.catch(() =&gt; {})</code>）</li><li>导航超时静默处理（适应 SPA 无导航场景）</li><li>每个用例独立开启/关闭 Page，<code>finally</code> 块确保资源释放</li><li>控制台错误仅记录告警，不直接判定失败</li><li><code>skip</code> 标记支持临时跳过不稳定用例</li></ul><hr><h2 id="六、技术亮点总结" tabindex="-1">六、技术亮点总结 <a class="header-anchor" href="#六、技术亮点总结" aria-label="Permalink to &quot;六、技术亮点总结&quot;">​</a></h2><table tabindex="0"><thead><tr><th>亮点</th><th>说明</th></tr></thead><tbody><tr><td><strong>配置驱动，零代码测试</strong></td><td>使用者只写配置对象，框架自动生成测试用例</td></tr><tr><td><strong>Shadow DOM 深度穿透</strong></td><td>递归遍历 + <code>&gt;&gt;&gt;</code> 穿透语法，完美适配 Web Components</td></tr><tr><td><strong>4 层白屏检测策略</strong></td><td>DOM 结构 + 内容长度 + 可见性 + SPA 挂载点，多维度交叉验证</td></tr><tr><td><strong>模块化配置架构</strong></td><td>按子站拆分，新增模块 3 步完成，零耦合</td></tr><tr><td><strong>全链路 TypeScript</strong></td><td>配置到执行全程类型安全，拼错即报错</td></tr><tr><td><strong>自动化告警闭环</strong></td><td>定时巡检 → 失败检测 → 企业微信推送 → Actions 日志溯源</td></tr><tr><td><strong>容错隔离设计</strong></td><td>单用例失败不扩散，资源自动回收，超时静默降级</td></tr></tbody></table><hr><h2 id="七、适用场景" tabindex="-1">七、适用场景 <a class="header-anchor" href="#七、适用场景" aria-label="Permalink to &quot;七、适用场景&quot;">​</a></h2><ul><li><strong>组件库官网巡检</strong>：防止发布后白屏、关键文档元素丢失</li><li><strong>多框架站点监控</strong>：一套框架覆盖 Vue / UniApp / 小程序 / 移动端等所有子站</li><li><strong>Web Components 场景</strong>：内置 Shadow DOM 穿透，开箱即用</li><li><strong>团队协作</strong>：配置与代码分离，产品/QA 也能编写测试配置</li></ul><p>这套框架的设计哲学是：<strong>把测试的复杂性封装进框架，把测试的简单性交还给用户</strong>。开发者只需要回答&quot;测哪个页面、检查什么元素、执行什么操作&quot;，剩下的一切——浏览器管理、Shadow DOM 穿透、白屏判定、CI 调度、失败告警——全部由框架接管。</p>',11))])}const y=p(c,[["render",g]]);export{B as __pageData,y as default};
