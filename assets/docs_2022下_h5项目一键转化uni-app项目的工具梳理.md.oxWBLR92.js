import{_ as e,c as l,o as i,ag as t}from"./chunks/framework.6d7lLjym.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2022下/h5项目一键转化uni-app项目的工具梳理.md","filePath":"docs/2022下/h5项目一键转化uni-app项目的工具梳理.md","lastUpdated":1746630943000}'),p={name:"docs/2022下/h5项目一键转化uni-app项目的工具梳理.md"};function s(n,a,o,d,r,c){return i(),l("div",null,a[0]||(a[0]=[t('<h2 id="_1-背景" tabindex="-1">1. 背景 <a class="header-anchor" href="#_1-背景" aria-label="Permalink to &quot;1. 背景&quot;">​</a></h2><p>h5项目要转为uni-app项目可以参考这篇<a href="https://ask.dcloud.net.cn/article/36174" target="_blank" rel="noreferrer">文章</a>，我们在实际处理过程中，开发了一系列工具，比如Eslint插件、nodejs脚本、Webpack loader、Webpack plugin等。这些工具特点不同，工作阶段不同，本篇文章旨在理清这些工具的差异和特点。</p><h2 id="_2-不同工具的作用阶段" tabindex="-1">2. 不同工具的作用阶段 <a class="header-anchor" href="#_2-不同工具的作用阶段" aria-label="Permalink to &quot;2. 不同工具的作用阶段&quot;">​</a></h2><p>一个普通的h5项目，从开发到上线运行会经过这些阶段：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>源代码 =&gt; 编译 =&gt; 打包产物 =&gt; 浏览器运行</span></span></code></pre></div><p>h5项目转为uni-app项目会比上面多一步：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>h5源代码 =&gt; uni-app代码 =&gt; 编译 =&gt; 打包产物 =&gt; 浏览器运行</span></span></code></pre></div><ul><li>Eslint插件，作用阶段为源代码开发阶段，包括h5源代码或者uni-app代码，主要是一些语法的转换</li><li>转换工具，本质是nodejs脚本，作用在h5源代码转为uni-app代码阶段，包括pages.json的生成、小程序main.js的生成等</li><li>Webpack-loader，作用在编译阶段，为uni-app代码编译成打包产物的阶段</li><li>Webpack-plugin，与上类似，但是功能更全面</li><li>运行时的代理，作用在运行时</li></ul><h2 id="_3-eslint插件和webpack-loader" tabindex="-1">3. Eslint插件和Webpack loader <a class="header-anchor" href="#_3-eslint插件和webpack-loader" aria-label="Permalink to &quot;3. Eslint插件和Webpack loader&quot;">​</a></h2><p>Eslint插件和Webpack loader内容有些重叠，有些功能既可以用Eslint插件实现，也可以用Webpack loader实现，这时候怎么区分呢？</p><p>假设对于一个问题或功能，有A、B两种实现方式，有下面几种情况：</p><ol><li>小程序只支持A，H5都可以支持，并且A、B两种方式对产品性能等指标没有影响</li><li>小程序只支持A，H5都可以支持，但是在H5上，B比A性能更佳</li><li>小程序只支持A，H5只支持B</li><li>小程序都可以支持，H5只支持B（基本不存在）</li><li>小程序和H5都可以支持</li></ol><p>下面我们分析下各种情况。</p><ul><li><p>第1种情况，应该用Eslint插件将B语法转为A。比如vue模板中<code>:childId=&quot;+childId&quot;</code>和<code>:childId=&quot;parseInt(childId, 10)&quot;</code>，这两种写法对性能几乎没影响。</p></li><li><p>第2种情况，不应该用Eslint插件，因为会损失h5上的性能。比如动态加载组件，h5上是需要的，并且有一定性能提升。</p></li><li><p>第3、4种情况，无法用Eslint插件，只能用Webpack loader或其他方式</p></li><li><p>第5种情况，不用处理</p></li></ul><h2 id="_4-尽早执行" tabindex="-1">4. 尽早执行 <a class="header-anchor" href="#_4-尽早执行" aria-label="Permalink to &quot;4. 尽早执行&quot;">​</a></h2><p>对于跨平台项目，对代码的改造应该越早越好，也就是说能用Eslint插件解决的，尽量不用转换工具、Webpack loader，能用转换工具解决的，尽量不用Webpack loader。</p><p>因为越往后，改动成本越高，越容易出错。并且Webpack loader并不是透明的，多个loader会相互影响，很容易引起一些bug。</p><h2 id="_5-不同工具功能梳理" tabindex="-1">5. 不同工具功能梳理 <a class="header-anchor" href="#_5-不同工具功能梳理" aria-label="Permalink to &quot;5. 不同工具功能梳理&quot;">​</a></h2><p>这里占个位，后面有空再整理。</p>',19)]))}const _=e(p,[["render",s]]);export{u as __pageData,_ as default};
