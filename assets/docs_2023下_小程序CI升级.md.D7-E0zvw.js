import{_ as a,c as i,o as l,ag as o}from"./chunks/framework.6d7lLjym.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/2023下/小程序CI升级.md","filePath":"docs/2023下/小程序CI升级.md","lastUpdated":1750086466000}'),p={name:"docs/2023下/小程序CI升级.md"};function r(t,e,c,d,n,s){return l(),i("div",null,e[0]||(e[0]=[o('<h2 id="_1-开始" tabindex="-1">1. 开始 <a class="header-anchor" href="#_1-开始" aria-label="Permalink to &quot;1. 开始&quot;">​</a></h2><p>之前介绍了强化版的小程序<a href="https://juejin.cn/post/7162908926764122142" target="_blank" rel="noreferrer">持续集成</a>，解决了一些手动上传效率低下的问题。</p><p>但仍存在一些问题：</p><ol><li>耗时久，<code>npm i</code>执行时间长，在大型项目中尤为突出</li><li>不支持pnpm，不能利用 pnpm 快 + 省空间的优势</li><li>依赖存在污染风险，有时候会报<code>xxx.wxss undefined</code>的错误</li><li>无法在本地用机器人账户上传</li></ol><h2 id="_2-解决" tabindex="-1">2. 解决 <a class="header-anchor" href="#_2-解决" aria-label="Permalink to &quot;2. 解决&quot;">​</a></h2><h3 id="_2-1-耗时久的问题" tabindex="-1">2.1. 耗时久的问题 <a class="header-anchor" href="#_2-1-耗时久的问题" aria-label="Permalink to &quot;2.1. 耗时久的问题&quot;">​</a></h3><p>之前流水线是写在一个脚本里的，脚本依次执行依赖安装、打包、ci上传等，也就是项目的依赖和ci依赖是一起安装的。</p><p>对于耗时久的问题，可以用<code>pnpm</code>解决，依赖安装可以由120s降到7s内。</p><p>但是<code>miniprogram-ci</code>并<a href="https://developers.weixin.qq.com/community/develop/doc/000e284b7d4bc09b194d0748356800" target="_blank" rel="noreferrer">不支持pnpm</a>，如何解决呢？</p><p>其实我们项目自身是支持<code>pnpm</code>的，只是这个工具不可以，那么可以分步进行，打包好之后交给ci工具即可，这样就解决了第1、2个问题。</p><p>另外ci工具的依赖是稳定的，可以固定一个环境，这样还可以解决第3个问题，即依赖污染问题。</p><p>需要注意的是，最后提交信息、版本信息需要获取到，并设置到全局变量中，因为打包和上传分离后，上传阶段已经拿不到原始仓库的信息了。</p><h3 id="_2-2-变量冲突" tabindex="-1">2.2. 变量冲突 <a class="header-anchor" href="#_2-2-变量冲突" aria-label="Permalink to &quot;2.2. 变量冲突&quot;">​</a></h3><p>上面提到的固定环境，会带来一个问题，就是不同项目的密钥、环境变量会发生冲突，甚至同一项目的分支、环境变量也会冲突，如何解决呢？</p><p>有两个方案：</p><ol><li>不直接用同一环境，而是不同流水线去复制这个环境的产物</li><li>利用<code>docker</code>，上传、预览在<code>docker</code>容器中执行</li></ol><p>两个方案我都实现了，并进行了对比。</p><p>第1个方案，优点是简单、快速，没有下载镜像、创建容器的过程，缺点是稳定性、灵活性差，只能在我的机器上跑，且仍有被误删、误改的可能性。</p><p>第2个方案，优点是稳定性、灵活性强，有版本控制，任何项目、团队都可以使用，缺点是速度较慢，构建环境准备过程最多会多耗时几十秒。</p><p>目前用的是第2个方案，构建环境并不会每次都销毁，也就是时间差距并没有那么明显，且稳定性更为重要。</p><h3 id="_2-3-本地上传与预览" tabindex="-1">2.3. 本地上传与预览 <a class="header-anchor" href="#_2-3-本地上传与预览" aria-label="Permalink to &quot;2.3. 本地上传与预览&quot;">​</a></h3><p>之前的执行方式是<code>bash</code>输出脚本，然后执行脚本，这样的问题是不直观，难调试。</p><p>现在做成CLI命令，可支持本地上传和预览。</p><h2 id="_3-效果" tabindex="-1">3. 效果 <a class="header-anchor" href="#_3-效果" aria-label="Permalink to &quot;3. 效果&quot;">​</a></h2><p>CI稳定性更强，耗时缩短。</p><p>以其中一项目为例，之前耗时6分35秒，现在耗时1分38秒，缩短297秒，减少约75.2%。</p><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2023/9/own_mike_3aa3fe433d4a8fac6d.png" width="220"><img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2023/9/own_mike_8bfd8fa8362fc429c4.png" width="500"><h2 id="_4-总结" tabindex="-1">4. 总结 <a class="header-anchor" href="#_4-总结" aria-label="Permalink to &quot;4. 总结&quot;">​</a></h2><p>本次优化，总结下来有下面几点：</p><ul><li>任务解耦</li><li>支持pnpm</li><li>缓存依赖</li><li>支持CLI命令</li></ul><p>总结下整个小程序CI，其由下面三个模块组成：</p><ul><li>配置模块，配置密钥、分支、环境、机器人等</li><li>任务调度，监控配置、更新执行模块</li><li>执行模块，流水线+CLI，完成打包、上传、预览、上报等任务</li></ul><p>麻雀虽小，五脏俱全。小程序CI搭建过程中体现的思想有：</p><ul><li>配置驱动，灵活、易维护</li><li>不同模块之前解耦，易扩展，任何模块都可替代</li><li>不同任务之间解耦，保证各单元可测试性，以及整体的稳定性、可用性</li></ul>',35)]))}const m=a(p,[["render",r]]);export{_ as __pageData,m as default};
